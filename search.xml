<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>爱，死亡，游戏制作人</title>
      <link href="/2021/05/07/2021-05-07-dream-reality-gameproducer/"/>
      <url>/2021/05/07/2021-05-07-dream-reality-gameproducer/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么选择游戏行业"><a href="#为什么选择游戏行业" class="headerlink" title="为什么选择游戏行业"></a>为什么选择游戏行业</h2><p>在刚准备转行做游戏的时候，面试的时候总会遇到这样的问题，时间一晃而过，已是八年光景。还记得当时我给出的回答是：<strong>想做一款好玩的游戏，能给人们带来快乐。</strong></p><p>当然，<em>游戏行业薪资高</em> 这个原由我是无论如何也说不出口的。</p><p>初入职场的那几年，自己真的就像白纸一样，对待什么都是好奇而敬畏。就像误入荷叶上的蚂蚁，遇到露珠便以为这是汪洋。很快，荷叶上的露珠都探索了遍，跌跌撞撞掉进了更加“广袤”的池塘。</p><span id="more"></span><blockquote><p><em>人在无知中探索，很容易发现乐趣。</em></p></blockquote><p>我始终认为，游戏应该给人带来快乐。如果你玩一款游戏不会捕获任何乐趣，那和机械地工作、繁重的学业又有什么区别呢？由此引发了我的第一个误区：<em>开发游戏也会带来乐趣。</em></p><p>其实这也真正构成了我当初选择游戏行业的初衷：__钱多__，__开心__。</p><p>有人说，钱多了自然就开心了。其实不然，人的物质追求总会有一个区域平缓的极限区间。即便你追求物质的欲望很大，那也不是通过打工能来实现的。马云曾经说过，他觉得月薪5万左右的打工人是最幸福的，不用背负过大的压力，又能满足一个普通人能感到幸福所需的物质保证。</p><p>也有人说，为了追求自己的理想，钱少一点也没关系，依旧会感觉很开心。也许拥有崇高理想的人真的会这样吧。但是一个臭作游戏的，能有多高尚？</p><h2 id="我所向往的游戏"><a href="#我所向往的游戏" class="headerlink" title="我所向往的游戏"></a>我所向往的游戏</h2><p>学生时代，网吧的普及使我对电子游戏产生了近乎疯狂的迷恋。</p><blockquote><p>反恐精英、红色警戒、暗黑、传奇、梦幻西游、魔兽世界、Dota ……</p></blockquote><p>这些个富有年代感的名字，都曾是我一次次奋战通宵的陪伴。当时的自己，还不关心这些游戏是用什么引擎做的，也不关心他们的DAU都多少，任凭多巴胺控制着大脑，享受纯粹的快乐。</p><p>以至于后来，我一直梦想着能做出令自己像当年一样 <strong>疯狂</strong> 的游戏。</p><p>2013年，我进入了第一家游戏公司。那一年，也是手游爆发的一年，资本疯狂的注入手游市场，恨不得你做个demo就能拿到融资。我也正是通过“改造”一个开源的游戏demo得以加入游戏行业。对了，那个游戏demo是基于Cocos2d-x写的，这也是我接触的第一个游戏引擎，虽然当时我还不知道游戏引擎究竟是干什么的。</p><p>雨后春笋般的手游应势而生，多数都是一些卡牌类游戏，玩家有如木偶一般被一路牵着走，做任务、收集、氪金……</p><p>很有幸，赶上了手游爆发的风口，在全民创业的大环境下，加入了一个还算靠谱的团队。虽然只是做棋牌游戏，但爆发式增长的用户，也让当时的我真正地见识到了互联网的魅力。棋牌游戏在那几年算是深受移动红利影响的游戏品种，也算是大家所谓的闷声发大财。虽然比不上某些横空出世的爆款游戏，但好在用户基础庞大，盈利模式清晰，有着比较稳定、可持续的发展轨迹。</p><p>也正因这样，我无需频繁地跳槽就能获得还算不错的薪资增长。虽然不能去做自己真正想做，或者说是可以令自己疯狂的游戏，但现实与物质的妥协让我渐渐将其变成了一句藏在心底的口号。</p><p>2018年，斯皮尔伯格的《头号玩家》，唤起了我也许已经麻木的内心：__绿洲__，或许就是我向往的游戏吧。</p><blockquote><p>一款让人分不清虚拟与现实的游戏，无尽的、待探索的广袤世界。</p></blockquote><p>希望有生之年，能够等到这样一款游戏横空出世，在一个虚拟的新世界重拾逝去的青春与激情。</p><h2 id="三十岁后的世界"><a href="#三十岁后的世界" class="headerlink" title="三十岁后的世界"></a>三十岁后的世界</h2><p>曾经的我，把三十岁这个节点看得很重。仿佛这一刻的到来，注定要完成什么与众不同的成就才对得起自己。也许是饱受 <strong>三十而立</strong> 思想的洗脑，亦或者那会儿焦虑贩子们宣扬程序员的淘汰年龄还只是三十岁而不是时下流行的三十五岁（或者未来也可能变成四十岁吧）。</p><p>但真的那天来的时候，确是那么的平淡无奇，让人想不出什么理由来赋予它特殊的意义。</p><p>如果说三十岁的我与之前有什么不同，那或许就是新增了一个身份吧———— __父亲__。小家伙的到来彻底改变了我的生活节奏，自己已经不记得上一次睡到自然醒是什么时候了，甚至连安逸地看一部完整电影的时间都没有。</p><h2 id="啊哈，游戏制作人"><a href="#啊哈，游戏制作人" class="headerlink" title="啊哈，游戏制作人"></a>啊哈，游戏制作人</h2>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>适合小白的PBR入门指南</title>
      <link href="/2020/07/06/2020-07-06-introduction-for-pbr/"/>
      <url>/2020/07/06/2020-07-06-introduction-for-pbr/</url>
      
        <content type="html"><![CDATA[<p>$$<br>{\mathcal L}<em>{cyc}(G,F)={\mathbb E}</em>{x \sim p_{data}(x)}[{|F(G(x))-x|}<em>{1}]+{\mathbb E}</em>{y \sim p_{data}(y)}[{|G(F(y))-y|}_{1}]<br>$$</p><p>$$<br>a = b + c<br>$$</p><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p><strong>PBR（Physically Based Rendering) 定义</strong></p><blockquote><p>使用基于物理原理和微平面理论建模的着色、光照模型，以及使用从现实中测量的表面参数来准确表示真实世界材质的理念。</p></blockquote><p><strong>微平面（Microfacet）理论</strong></p><blockquote><p>任何物体表面，微观层面上都是由许多随机凹凸不平的微面元（光学光滑）构成，物体表面的粗糙度越高，微面元的排列就越混乱。</p></blockquote><span id="more"></span><p><strong>能量守恒</strong></p><blockquote><p>出射光线的能量永远不能超过入射光线的能量（发光面除外）。</p></blockquote><p><strong>辐射通量（Radiant Flux）</strong></p><blockquote><p>每单位时间的辐射能量，单位符号是<em>W(瓦特)</em> 。这里可以理解为是一个光源所输出的能量，由于光的能量实际上是由不同波长的能量集合而成，且每种波长与一种特定的颜色相关，因此可以使用RGB编码来作为辐射通量表示的简化。</p></blockquote><p><strong>立体角（Solid Angle）</strong></p><blockquote><p>以观测点为球心，构造一个单位球面，任意物体投影到该单位球面上的投影面积，即为该物体相对于该观测点的立体角。因此，立体角是单位球面上的一块面积。</p></blockquote><p><img src="evernotecid://6D7754FF-5764-46D0-96E1-1661E5593622/appyinxiangcom/4970874/ENResource/p2746" alt="47fd7fcba4edcf87378325be26536939.png"></p><p><strong>辐射率（Radiance）</strong></p><blockquote><p>用来量化单一方向上发射来的光线的大小或强度，及每单位立体角、每单位投射表面的辐射通量，单位符号是 *W / sr * m^2(瓦特每球面度每平方米)*。</p></blockquote><p><strong>辐射强度（Radiant Intensity）</strong></p><blockquote><p>在单位球面上，一个光源向每单位立体角所投送的辐射通量。</p></blockquote><p><strong>辐照度（Irradiance）</strong></p><blockquote><p>入射表面的辐射通量, 及所有投射到点p上的光线的总和。</p></blockquote><h3 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h3><p><strong>渲染</strong>到底是什么？</p><p>Jams Kajiya在1986年发表的《The Rendering Equation》论文中给出了渲染方程的表述形式，基于数学建模的角度描述了渲染到底是什么，具体公式如下：</p><p>$$<br>L_o(v) = L_e(v) + \int_{\Omega}^{}f(\omega_i,v)L_i(\omega_i)(n\cdot\omega_i)d\omega_i<br>$$</p><p>相信很多人可能会被这个繁杂的公式劝退，想要更好地去理解它，就需要我们根据之前所介绍的相关概念，对这个公式进行一步步的拆解，也就是化繁为简。</p><p>公式中 <strong>L</strong> 表示辐射率，渲染方程所要表述的内容就是：从某一点到观察点（眼睛）方向上的出射辐射率等于该方向上的自发光辐射率，加上所有有效入射光到观察点的辐射率积分和。</p><p>其中，去除自发光的部分，剩余的积分计算就是著名的 <strong>反射等式（Reflectance Equation）</strong>，它主要描述的是基于反射点构建的 <strong>半球领域（Hemisphere）</strong> 中所有入射光经反射到人眼的辐照度。</p><p>此时，可以将立体角想象成无穷小，因此对应的辐射率也就表示光线穿过空间中某一点的辐射通量。这样也便于我们在着色器程序中使用辐射率来计算光线对片元的作用。</p><p>图形学中，我们可以利用精确光源（点光源、平行光、聚光灯）来简化反射等式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L_o(v) = &#123;\pi&#125;f(l_c,v)c_&#123;light&#125;(n&#123;\cdot&#125;l_c)</span><br></pre></td></tr></table></figure><p>当场景中存在多个精确光源，只需要对公式的计算结果进行简单的累加即可。</p><p>继续拆解分析下精确光源下简化后的反射等式。</p><p>首先是  <em>(n⋅l)</em> 部分。</p><p>通常我们会利用入射光线方向与反射点所在平面的法线进行内积运算，以此来表示该点的反射光的强度。一般用辐照度来表示光的强度，也就是投射到某一区域的所有光线总和。</p><p><img src="evernotecid://6D7754FF-5764-46D0-96E1-1661E5593622/appyinxiangcom/4970874/ENResource/p2747" alt="740476d28a3d8904282a197ce6ceb8f7.png"></p><p>如上图，假设光线之间平行且距离 <strong>d</strong> 保持不变，投射到反射平面上的间隔距离 <strong>L</strong> 可以根据光线方向与法线方向的夹角余弦来推出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L = \frac &#123;d&#125;&#123;cos\theta&#125;</span><br></pre></td></tr></table></figure><p>由此可知，某个区域的光线越密集（辐照度越高），则L也就越小，因此不难推出，辐照度实际上是跟光线与法线的夹角余弦成正比的。而想要求出两个向量的夹角余弦，用对应的单位向量进行内积运算即可。</p><p>下面说说这个 π 是怎么来的。</p><p>设想一个最最简单的情况，入射光从四面八方射入，并保证亮度一致，这样我们就可以将常数提到积分外面，并且内积运算改用余弦函数表示，反射等式就成了下面这个样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L_o(v) = f(\omega_i,v)L_i\int_&#123;\Omega&#125;^&#123;&#125;cos&#123;\theta&#125;d\omega_i</span><br></pre></td></tr></table></figure><p>公式中的积分部分，我们称作<strong>立体角积分</strong>。可以把立体角想象成无穷小，与球体相交的截面也就是球体表面的微元，积分运算实际上也就是求球体的表面积，因此上述积分可以分解成球体表面积分和cos</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\int_&#123;-\pi&#125;^&#123;\pi&#125;\int_&#123;0&#125;^&#123;\frac &#123;\pi&#125;&#123;2&#125;&#125;sin&#123;\theta&#125;cos&#123;\theta&#125;&#123;d\theta&#125;&#123;d\phi&#125;</span><br></pre></td></tr></table></figure><p>根据余弦定理，可以将里面的积分改写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\int_&#123;0&#125;^&#123;\frac &#123;\pi&#125;&#123;2&#125;&#125;sin&#123;\theta&#125;cos&#123;\theta&#125;d\theta = \frac &#123;1&#125;&#123;2&#125;[sin^2(\frac &#123;\pi&#125;&#123;2&#125;) - sin^2(0)] = \frac &#123;1&#125;&#123;2&#125;</span><br></pre></td></tr></table></figure><p>再放回外层的积分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\int_&#123;\Omega&#125;^&#123;&#125;cos\theta&#123;d\omega_i&#125; = \int_&#123;-\pi&#125;^&#123;\pi&#125;\frac &#123;1&#125;&#123;2&#125;&#123;d\phi&#125; = \pi</span><br></pre></td></tr></table></figure><p>讲到这里，就只剩下f(wi, v)部分了。这个函数实际上就是之前渲染方程的一个简化计算，描述了已知入射光，会有多少百分比的光反射到观察方向上。在图形学中，这个函数有一个专门的名字：双向反射分布函数，即BRDF。</p><h3 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h3><p>BRDF英文全称为 Bidirectional Reflectance Distribution Function，中文译作双向反射分布函数。它在渲染方程中的作用就是来确定所有出射方向上的反射和散射光线的相对分布情况。因此，BRDF又可以拆分成两个部分：<strong>高光反射项</strong>（对应表面反射）和<strong>漫反射项</strong>（对应次表面散射），我们将这种模型称之为 <strong>Cook-Torrance BRDF模型</strong>。</p><h4 id="漫反射项"><a href="#漫反射项" class="headerlink" title="漫反射项"></a>漫反射项</h4><p>最简单、应用最广泛的漫反射BRDF就是 Lambert模型了，它的公式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f_&#123;Lambert&#125;(l, v) = \frac &#123;Color_&#123;diffucse&#125;&#125;&#123;\pi&#125;</span><br></pre></td></tr></table></figure><p>这里为什么又要除以一个 π ？</p><p>之前我们已经推导出了出射辐射率的公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L_o = &#123;\pi&#125;f(\omega_i,v)L_i = \pi * BRDF * L_i</span><br></pre></td></tr></table></figure><p>为了使着色是基于物理的，就需要BRDF去遵守能量守恒定律，即出射光线的能量要小于等于入射光线的能量。假设所有射向受光面一点的入射辐照率都为Li，那么实际的辐射通量应该等于辐射率乘以半球的表面积。由于能量守恒，入射光能量等于出射光能量。于是我们不难得出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F_o = 2\pi&#123;L_o&#125; = 2\pi*\pi*BRDF*L_i = F_i = 2\pi&#123;L_i&#125;</span><br></pre></td></tr></table></figure><p>这里只有让BRDF等于1/π才能保证等式相等，这也是为什么Lambert漫反射模型会去除以一个 π 的原因了。</p><p>但有些时候，Lambert模型还是存在一些局限性，为了表现出更加真实模拟次表面散射的效果，就需要用到更复杂的漫反射项，这方面最著名并广泛使用的就是大名鼎鼎的<strong>迪士尼原则的BRDF</strong>，它的漫反射项就复杂多了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f_&#123;diff&#125;(l, v) = \frac &#123;baseColor&#125;&#123;\pi&#125;(1 + (F_&#123;D90&#125; - 1)(1 - n&#123;\cdot&#125;l)^5)(1 + (F_&#123;D90&#125; - 1)(1 - n&#123;\cdot&#125;v)^5))</span><br></pre></td></tr></table></figure><p>其中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F_&#123;D90&#125; = 0.5 + 2roughness(h&#123;\cdot&#125;l)^2</span><br></pre></td></tr></table></figure><p>Disney使用了Schlick菲涅耳近似等式来模拟在掠射角的反射变化，同时使用表面粗糙度来进一步修改它，既保证光滑材质可以在掠射角具有更加明显的阴影边，又使得粗糙材质在掠射角具有亮边。</p><h4 id="高光反射项"><a href="#高光反射项" class="headerlink" title="高光反射项"></a>高光反射项</h4><p>如果只考虑漫反射效果，渲染出来的画面并不够真实。所以，BRDF中的高光反射项也尤为重要，并且也更加复杂。</p><p>这里需要先回顾一下微平面理论：物体的表面由许多微面元构成，每个微面元被认为是光学平滑的，具有完美的高光反射。由于入射光线或出射光线都存在可能被其他某个微面元挡住，所以不会添加到高光反射项的计算中。如下图，左侧某些入射光被凸起的微面元遮挡，黑色虚线投射的部分会形成阴影；右侧出射时被遮挡的部分，则不会看见对应的高光反射。</p><p><img src="evernotecid://6D7754FF-5764-46D0-96E1-1661E5593622/appyinxiangcom/4970874/ENResource/p2752" alt="e9fef40c610d12217129af0369f52a60.png"></p><p>基于这些假设，我们可以使用下面的通用形式来表示BRDF的高光反射项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f_&#123;spec&#125; = \frac &#123;FGD&#125;&#123;4(n&#123;\cdot&#125;l)(n&#123;\cdot&#125;v)&#125;</span><br></pre></td></tr></table></figure><p>分母部分是用于校正从微面元的局部空间到宏观整体表面的局部空间变换的校正因子。</p><p>分子项里的FGD分别表示：菲涅耳方程（<strong>F</strong>resnel Equation）、几何函数（<strong>G</strong>eometry Function）和法线分布函数（Normal <strong>D</strong>istribution Function）。</p><h5 id="菲涅耳方程"><a href="#菲涅耳方程" class="headerlink" title="菲涅耳方程"></a>菲涅耳方程</h5><p>该方程描述了光学表面反射光线对比折射光线所占的比率，当光照方向和观察方向夹角逐渐增大时高光反射强度对应增大。完整的菲涅耳方程十分复杂，为了给美术人员提供更加直观、便利的调节参数，一般会选择使用 <strong>Fresnel-Schlick 近似等式</strong>来求得近似解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F_&#123;Schlick&#125;(l, h) = Color_&#123;spec&#125; + (1 - Color_&#123;spec&#125;)(1 - (l&#123;\cdot&#125;n))^5</span><br></pre></td></tr></table></figure><p>一般来说，金属材质的高光反射颜色（0.7<del>1.0）要高于非金属材质的高光反射颜色（0</del>0.45）。</p><h5 id="法线分布函数"><a href="#法线分布函数" class="headerlink" title="法线分布函数"></a>法线分布函数</h5><p>假设每个微面元的法线为<strong>m</strong>，向量<strong>h</strong>等于入射光方向与平面法线的一半，法线分布函数则表示了当前表面有多少比例的微面元满足 <strong>m</strong>=<strong>h</strong>，它是一种近似的比率，必须是非负的标量。最终结果跟表面的粗糙度有一定的关系，当粗糙度下降时，理论上应该有更多的微面元满足<strong>m</strong>=<strong>n</strong>。</p><p>比较常见的法线分布函数有GGX，也叫Trowbridge-Reitz NDF，它的公式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D_&#123;GGX&#125;(h) = \frac&#123;&#123;\alpha&#125;^2&#125;&#123;\pi((&#123;\alpha&#125;^2 - 1)(n&#123;\cdot&#125;h)^2 + 1)^2&#125;</span><br></pre></td></tr></table></figure><p>在这里<strong>h</strong>表示用来与平面上微平面做比较用的中间向量，而<strong>a</strong>表示表面粗糙度。</p><p>当粗糙度很低（也就是说表面很光滑）的时候，与中间向量取向一致的微平面会高度集中在一个很小的半径范围内。由于这种集中性，NDF最终会生成一个非常明亮的斑点。但是当表面比较粗糙的时候，微平面的取向方向会更加的随机。你将会发现与h向量取向一致的微平面分布在一个大得多的半径范围内，但是同时较低的集中性也会让我们的最终效果显得更加灰暗。</p><p><img src="evernotecid://6D7754FF-5764-46D0-96E1-1661E5593622/appyinxiangcom/4970874/ENResource/p2755" alt="cca46696de64652c21eb88b921e4a811.png"></p><p>而在Disney BRDF中，选择了一种更加广义的法线分布模型：<strong>Generalized-Trowbridge-Reitz(GTR)分布</strong>。GTR分布与GGX分布十分类似，不同的是它的分母指数是一个可调参数，并且<strong>a</strong>表示的是表面粗糙度的平方。</p><h5 id="几何函数"><a href="#几何函数" class="headerlink" title="几何函数"></a>几何函数</h5><p>根据微平面原理我们知道，光线在传播的过程中，很可能会被物体的一些微面元挡住而无法显示出高光颜色。这个几何函数，就是为了近似计算出微面元之间相互遮蔽的概率。</p><p>同样的，会使用粗糙度作为几何函数的输入参数，因为粗糙度较高的表面其微面元间相互遮蔽的概率也更高。学术上有很多几何函数的分析模型，这里我们只介绍其中一种，即<strong>Schlick-GGX</strong>，公式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G_&#123;SchlickGGX&#125;(n, v, k) = \frac&#123;n&#123;\cdot&#125;v&#125;&#123;(n&#123;\cdot&#125;v)(1 - k) + k&#125;</span><br></pre></td></tr></table></figure><p>这里的k是 <em><strong>a</strong></em> 基于几何函数是针对直接光照还是针对IBL光照的重映射，同时还要注意粗糙度转化为 <em><strong>a</strong></em> 的方式。</p><p>为了有效的估算，需要兼顾考虑观察方向和光线入射方向的遮蔽情况。利用<strong>Smith Method</strong>来把两者相乘：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G_&#123;smith&#125; = G_&#123;SchlickGGX&#125;(n, v, k)G_&#123;SchlickGGX&#125;(n, l, k)</span><br></pre></td></tr></table></figure><p>介绍到这里，我们发现BRDF里的高光反射项，<strong>FDG</strong>每个部分都有不同形式的模型，这也造就了各式各样的BRDF。举例来说，UE4引擎中使用的<strong>FDG</strong>函数就分别是：Fresnel-Schlick近似、Trowbridge-Reitz GGX、Smith’s Schlick-GGX。</p><h3 id="IBL"><a href="#IBL" class="headerlink" title="IBL"></a>IBL</h3><p>如果只考虑直接光照，我们渲染出来的物体还是没办法看上去那么“物理“，这就需要考虑上环境光。一个通用的解决方案就是IBL，全称 <strong>Image Based Lighting</strong>，基于图像的光照。它的做法就是使用一张通过场景生成的立方体贴图，贴图纹素中存储着光照信息，片元着色阶段就可以根据片元法线方向对环境光立方体贴图进行采样，并将结果添加进光照计算中。</p><p>这里我们再来回顾一下之前推导的反射方程（拆分为漫反射项和高光反射项）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L_o = \int_&#123;\Omega&#125;^&#123;&#125;\frac&#123;C_&#123;diffuce&#125;&#125;&#123;\pi&#125;L_i(p, \omega_i)n&#123;\cdot&#125;\omega_id\omega_i + \int_&#123;\Omega&#125;^&#123;&#125; \frac&#123;FDG&#125;&#123;4(\omega_o&#123;\cdot&#125;n)(\omega_i&#123;\cdot&#125;n)&#125;L_i(p, \omega_i)n&#123;\cdot&#125;\omega_id\omega_i</span><br></pre></td></tr></table></figure><p>漫反射部分的结果通常是通过卷积计算出来的，即对半球领域上的大量方向进行离散采样，并将辐照度取平均值，来计算每个输出采样方向的总和。因此，对立方体贴图中的每个采样方向做漫反射计算，都需要考虑半球领域上的所有其他采样方向。这样的立方体贴图也被称为<strong>辐照度图</strong>。</p><p>由于漫反射计算需要依赖于光线受照位置 <strong>p</strong>，如果只考虑它位于中心位置的情况，那么所有漫反射间接光只能都来自同一张环境光立方体贴图，在一些狭小的空间下会破坏现实感。一般游戏引擎中，会采用<strong>反射探针（Reflection Profobes）</strong> 机制来解决这个问题。每个反射探针单独预先计算好周围环境的辐照度图，位置<strong>p</strong>处的辐照度是取离着最近的几个反射探针之间的辐照度插值。</p><p>下图就是一个环境立方体贴图及其生成的辐照度图：</p><p><img src="evernotecid://6D7754FF-5764-46D0-96E1-1661E5593622/appyinxiangcom/4970874/ENResource/p2756" alt="f79e668494d54e25edb9ea698f5f9d5e.png"></p><p>镜面反射部分的IBL就更加复杂一些，同时受到入射光方向和视角方向的影响。如果试图解出所有入射光方向和视角方向的积分，实时计算代价极为高昂。于是，有人提出了一种折中的解决方案：<strong>分割求和近似法（Spit Sum Approximation）</strong>。</p><p>分割求和近似法将镜面反射积分拆解成两个独立的部分。</p><p>第一部分被称为<strong>预滤波环境贴图</strong>，类似与辐照度图，但考虑了粗糙度的因素。随着粗糙度的增加，反射就更模糊，并将不同粗糙度下的结果存储在预滤波贴图的Mipmap中。如下图所示：</p><p><img src="evernotecid://6D7754FF-5764-46D0-96E1-1661E5593622/appyinxiangcom/4970874/ENResource/p2758" alt="7265d07e7c178c02815ee4ed1f037058.png"></p><p>第二部分是<strong>环境BRDF</strong>，假设每个方向的入射辐射率都等于1，在给定粗糙度、光线与法线内积（夹角）的情况下，预计算BRDF的结果，并将其存储在一张2D<strong>查找纹理（LUT）</strong>上，也称为<strong>BRDF积分贴图</strong>。</p><p><img src="evernotecid://6D7754FF-5764-46D0-96E1-1661E5593622/appyinxiangcom/4970874/ENResource/p2759" alt="18cca815a1854c807625e5db5020c2c9.png"></p><p>参考上图，输入的uv坐标分别对应<strong>入射光线与法线夹角的余弦</strong>和<strong>粗糙度</strong>，对应输出的是环境BRDF镜面反射的强度，R通道存放着菲涅耳缩放系数，G通道存放着偏差值。</p><hr><h4 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h4><p><a href="http://candycat1992.github.io/unity_shaders_book/unity_shaders_book_chapter_18.pdf">Unity入门精要 第18章 基于物理的渲染</a><br><a href="https://zhuanlan.zhihu.com/p/21489591">如何看懂这些该死的图形学公式</a><br><a href="https://learnopengl-cn.github.io/07%20PBR/01%20Theory/">LearnOpenGL PBR理论</a><br><a href="https://learnopengl-cn.github.io/07%20PBR/03%20IBL/01%20Diffuse%20irradiance/">LearnOpenGL 漫反射辐照度</a><br><a href="https://learnopengl-cn.github.io/07%20PBR/03%20IBL/02%20Specular%20IBL/">LearnOpenGL 镜面反射 IBL</a><br><a href="https://zhuanlan.zhihu.com/p/53086060">基于物理的渲染白皮书（一）开篇</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>纹理那些事儿</title>
      <link href="/2020/06/21/2020-06-21-something-about-texture/"/>
      <url>/2020/06/21/2020-06-21-something-about-texture/</url>
      
        <content type="html"><![CDATA[<h3 id="纹理概述"><a href="#纹理概述" class="headerlink" title="纹理概述"></a>纹理概述</h3><p>在计算机图形学中，<strong>纹理(Texture)</strong> 是我们经常会提及的一个名词。</p><p>直观的第一印象，很容易会将纹理理解成一张图片，实际上在计算机图形学中，我们也确实会经常通过一张张格式诸如png、jpg之类的图片来获得纹理数据。</p><p>但在图形学中，纹理更多地是被认作 <strong>一块数据</strong>，它也不再局限在2D空间，也会有一维纹理、三维纹理、立方体映射纹理、数组纹理等。</p><p>纹理是由 <strong>纹素（texel）</strong> 构成的，每个纹素记录着相应的颜色信息，它类似于屏幕的 <strong>像素（pixel）</strong> 但又与像素不保证是一一对应的。</p><p>那么纹理为什么会被广泛使用呢？</p><span id="more"></span><p>这是因为，我们看到现实世界中所呈现出丰富的颜色，是由于不同物体会吸收一部分光的波长并反射出另一部分出来（如红色物体实际上是因为反射了大部分红色波长出来），最终通过眼睛传入大脑计算成像。而通过计算机去实时模拟这一过程无疑是复杂且耗时的，尤其是游戏要求在短短的一帧（少于0.016s）中就完成一次场景渲染。</p><p>为了解决这个问题，人们想到了一个办法：找到一张图片（离线渲染生成），然后把它“粘”在物体的表面上，就像贴墙纸一样。而这一“粘”的过程，我们管它叫做 <strong>纹理映射（texture mapping）</strong>，实际上也就是一块纹理数据与3D模型建立关联的过程。</p><p>看过武侠小说的应该都听说过“易容术”，将不同的“人皮子”贴在脸上，就可以易容成别人的模样。其实这就是一个简单的纹理映射的过程。</p><p><img src="https://s1.ax1x.com/2020/06/22/N8zztg.jpg" alt="N8zztg.jpg"></p><p>有人可能会有疑问，每个人的面部肌肉都不尽相同，仅用一张纹理是怎么做到“易容”的呢？卖个关子，后面在纹理的应用中会有介绍。</p><h3 id="纹理映射原理"><a href="#纹理映射原理" class="headerlink" title="纹理映射原理"></a>纹理映射原理</h3><p>在渲染管线中，一般在 <strong>片元着色阶段</strong> 最常使用纹理。</p><p>在美术建模时，会为每个顶点分配一个纹理坐标，也被叫做UV坐标。在进入光栅化阶段，生成的每个fragment会根据相关顶点的纹理坐标差值后新的uv，根据这个uv来对传入的纹理数据进行<strong>采样（使用纹理坐标获取纹理颜色）</strong>。</p><p><img src="https://s1.ax1x.com/2020/06/22/N8zg61.jpg" alt="N8zg61.jpg"></p><p>根据上图说明一下简单的纹理映射，某个三角形包含三个顶点，对应记录的uv坐标分别是(0,0)、(1,0)和(0.5,1)。光栅化之后，每个小格子就是一个fragment，对应屏幕的像素。在这个三角形区域中的每个像素，会根据顶点所记录的纹理坐标来进行差值计算，这就涉及到了三角形内的重心坐标计算。</p><p><img src="https://s1.ax1x.com/2020/06/22/N8zf0K.jpg" alt="N8zf0K.jpg"></p><p>如上图，已知三角形ABC内任意一点(x, y)以及三个顶点ABC的位置，即可求出该点相对三角形的重心坐标位置。进而可以计算出该点所在像素对应的UV坐标：</p><blockquote><p>(u, v) = 𝛼A(u,v) + 𝛽B(u,v) + 𝛾C(u,v)</p></blockquote><p>一般来说，纹理坐标的范围都是[0, 1]，但在某些情况下，可能会使用超出该范围的结果。例如墙面纹理，我们可以只制作一块砖的纹理图片，在根据模型实际宽度来放大顶点纹理坐标，使得可以循环重复采样同一块砖的纹理。这就涉及到了设置<strong>纹理环绕方式</strong>，在OpenGL中，常见的选择如下：</p><table><thead><tr><th>环绕方式</th><th>描述</th></tr></thead><tbody><tr><td>GL_REPEAT</td><td>对纹理的默认行为，重复纹理图像</td></tr><tr><td>GL_MINRRORED_REPEAT</td><td>和GL_REPEAT一样，但是镜像重复纹理图像</td></tr><tr><td>GL_CLAMP_TO_EDGE</td><td>超出[0,1]部分的纹理坐标，重复边缘（拉伸）</td></tr><tr><td>GL_CLAMP_TO_BORDER</td><td>超出[0,1]部分的纹理坐标，指定边缘颜色</td></tr></tbody></table><p><img src="https://s1.ax1x.com/2020/06/22/N8z2Ox.jpg" alt="N8z2Ox.jpg"></p><p>还有一种比较常见的灵活纹理采样方式，就是UV序列帧动画。美术会做好一张 N * N 的图片，最最常见的就是火焰效果了。</p><p><img src="https://s1.ax1x.com/2020/06/22/N8zclR.jpg" alt="N8zclR.jpg"></p><p>每次在片元着色器对该纹理进行采样的时候，根据一定的频率来调整修改需要传入的UV坐标，使得每次恰好只截取展示其中的一个tile，连续起来会实现出帧动画的效果。</p><p>说到这里不难发现，跟纹理打交道，本质上就是确定<strong>数据内容</strong>和<strong>采样方式</strong>。在片元（像素）着色器中，根据UV坐标对纹理数据中对应纹素的颜色进行提取，再渲染到像素中去。但是，这仅仅是最简单、理想的情况。无论是纹素还是像素，你都可以理解为它们是有<strong>大小</strong>的，只不过人眼不易察觉罢了，毕竟现在手机一般都是<em>1920 * 1020</em>分辨率起步的，还是仅仅在一块6寸大小的空间下。</p><p>当纹素与像素的大小比例过于悬殊时，会出现一些明显的“锯齿”现象，下面会从两种情况分别介绍。</p><h4 id="纹理过小"><a href="#纹理过小" class="headerlink" title="纹理过小"></a>纹理过小</h4><p>假设一张 <em>480 * 270</em> 尺寸的纹理要铺满渲染到分辨率为 <em>1920 * 1080</em> 的屏幕上，此时一个纹素的大小可以理解为是像素的4倍。而在片元着色阶段，默认会根据差值计算生成的纹理坐标，找到离该片元最近的纹素，并采样提取其颜色。</p><p><img src="https://s1.ax1x.com/2020/06/22/N8zWm6.jpg" alt="N8zWm6.jpg"></p><p>如图，红色点是我们实际想要采样的纹理坐标（由于像素更小，所以采样点会更加精密），而黑色是实际上采样到的纹理坐标对应的颜色。所谓的<strong>锯齿（aliasing）</strong>，就是这么来的：紧挨红色点的右侧和上方，会跟着采样出同一纹素的颜色，但是离红色点更近的左侧部分，却只能采样到相邻左侧纹素的颜色。离着相对较远的两个像素，可以采样出同一种颜色出来，而明明离得更近的两个像素，却只能采样出两个纹素的颜色（有可能颜色差异比较明显）。</p><p>那么如何解决这个问题呢？</p><p>答案就是：<em><strong>双线性过滤（Bilinear Filtering）</strong></em></p><p>先简单介绍一下线性差值的计算，几乎在计算机图形学中经常用到，就是已知 <em>v0</em> 和 <em>v1</em> 两个值，以及一个线性比例，求出该线性比例下对应的值，具体公式如下：</p><blockquote><p>lerp(x, v0, v1) = v0 + x (v1 - v0)</p></blockquote><p>所谓的双线性过滤，就是根据某一像素的纹理坐标，找到其周围四个纹素的位置并采样其颜色，通过横向、纵向分别进行差值计算，得到最终的颜色。</p><p><img src="https://s1.ax1x.com/2020/06/22/N8zIte.jpg" alt="N8zIte.jpg"></p><p>上图就展示了双线性过滤的基本过程：先找到红色采样点周围的四个纹素位置，采样得到4个颜色分别为 <em>u01</em>、 <em>u11</em>、 <em>u00</em>、 <em>u10</em> ，先横向根据 <em>u01</em> 和 <em>u11</em> 线性差值得到 <em>u1</em> ，<em>u00</em> 和 <em>u10</em> 线性差值得到 <em>u0</em>，再通过 <em>u1</em> 和 <em>u0</em> 进行线性差值得到最终的颜色。</p><p>这样的双线性过滤得到的效果，较之前的 <strong>邻近过滤</strong> 方式，会呈现出更加平滑的颜色过渡，“锯齿感”明显减少了。</p><p><img src="https://s1.ax1x.com/2020/06/22/N8z5kD.jpg" alt="N8z5kD.jpg"></p><p>其实还有个<strong>三线性过滤（Trilinear）</strong>，虽然能得到更加平滑自然的效果，但是计算成本更高，这里就不再展开讨论了。</p><h4 id="纹理过大"><a href="#纹理过大" class="headerlink" title="纹理过大"></a>纹理过大</h4><p>说完纹理过小，我们再来讨论下纹理过大的情况。也许你心中会有疑惑，纹理过大也不行？</p><p>其实道理类似，纹理过大，每个纹素的大小相较于像素更小了，就导致每个像素覆盖的区域实际上会包含多个纹素，但在片元着色阶段只会进行一次<strong>点采样</strong>，得到的结果显然是不够“精密”的。从信号学的角度上来理解，每个像素的信号频率远远低于纹理上的信号频率，于是也会形成锯齿的效果。假设一张特别大的纹理贴在地面上，由于透视的近大远小效果，会放大像素与纹素的信号频率差距，因此远处的地面会形成“摩尔纹”的景致。</p><p><img src="https://s1.ax1x.com/2020/06/22/N8zofH.jpg" alt="N8zofH.jpg"></p><p>解决这个问题一个最直观的办法就是 <strong>超级采样（Super Sampling）</strong> ，既然每个像素只采样一次不足以覆盖包含的所有纹素的话，那就多采样几次，并将最终的采样结果中和一样，生成该像素的颜色。</p><p>超级采样虽然的确能以较高的质量解决锯齿问题，但计算成本实在是太高了！尤其是很远处的像素，为了抗锯齿进行了大量的多重采样，人眼看到的结果却无法辨别细节，这无疑是一种严重的浪费。（当然，如果性能条件允许，这么做也无可厚非。）</p><p>为了能够高效获取某一像素下对应纹理的某一区域颜色，计算机图形学中的常见解决方案是：将一块纹理生成一系列的纹理图像，其中后一个纹理图像是前一个尺寸的二分之一。这种解决方案叫做 <strong>多级渐远纹理（Mipmap）</strong> ，其中 <em>Mip</em> 一词源于拉丁语，意为 <em>一小块空间下许多细小的东西 （multum in parvo）</em> 。</p><p><img src="https://s1.ax1x.com/2020/06/22/N8zhTO.jpg" alt="N8zhTO.jpg"></p><p>Mipmap是一种典型的空间换时间的解决手段，通过<strong>范围查询</strong>来替代之前双线性差值所做的<strong>点查询</strong>，它的好处就是速度快，但是也有缺点：结果不够准确、只能用于正方形(2的幂次方）贴图，以及增加了额外的存储量（增量约为1/3）。</p><p>我们如何确定该使用那一层的Mip呢？道理其实很简单：</p><p><img src="https://s1.ax1x.com/2020/06/22/N8z7pd.jpg" alt="N8z7pd.jpg"></p><p>假设一个三角形覆盖屏幕一定区域的像素，其中选择一红色的采样点以及其相邻的3个采样点（都是红色），映射到纹理坐标系下，求出两个像素采样点在纹理坐标系下的近似长度 <em>L</em> 以及一块粉红色的区域。根据这块区域的近似面积以及纹素的大小，就可以得出该使用哪个层的Mip了。</p><p>比如：</p><p><em>如果正好是一个纹素的大小，也就是一个像素对应一个纹素，那么就选择第0层的Mip</em></p><p><em>如果对应四个纹素的大小，也就是一个像素对应4个纹素，那么就选择第1层的Mip</em></p><p>以此类推，得出上图中出现的公式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D = log&#123;2&#125;L</span><br></pre></td></tr></table></figure><p>当计算出的层数恰好不是整数的时候（事实上经常会出现这种情况），同一纹理上的不同Mip之间会出现明显的断层现象，如下图底部的红色区域，深红色直接过渡到鲜红色，十分地不自然。</p><p><img src="https://s1.ax1x.com/2020/06/22/N8zb6I.jpg" alt="N8zb6I.jpg"></p><p>出现了这种不自然的平滑过渡，解决办法依然是：<strong>差值</strong> ！</p><p>假设计算出的Mip层数是0.7，那么需要将该采样点在第0层和第1层分别进行双线性差值，然后再将两个Mip计算出的颜色结果再进行一次线性差值，得到最终的颜色。我们管这种计算方法叫做：<strong>三线性差值（Trilinear Interpolation）</strong>。</p><p>下图是使用三线性差值后的表现，是不是平滑了许多？</p><p><img src="https://s1.ax1x.com/2020/06/22/N8zX0f.jpg" alt="N8zX0f.jpg"></p><p>但是某些情况下，使用三线性差值计算出的Mipmap颜色依旧会有问题。类似开放世界的第一人称视角，看向很远处的位置，可能会产生出over blur的效果。还记得Mipmap的缺点吗？它只能针对正方形纹理进行Mip分层，当透视效果越明显，越远处的像素对应纹理中的区域会越不接近正方形（更像长条的巨型），如果使用面积更大的正方形来包住这个矩形区域，此时的差值结果就会愈加不准确，造成了越远处越模糊的感觉。</p><p>为了解决这个问题，很多硬件都支持 <strong>各项异性过滤</strong>，例如OpenGL中可以通过 <em>GL_TEXTURE_MAX_ANISOTROPY_EXT</em> 来设置纹理中各项异性过滤的数值。</p><p><img src="https://s1.ax1x.com/2020/06/22/N8zOnP.jpg" alt="N8zOnP.jpg"></p><p>上图左侧为三线性差值，右侧为将各向异性设置到最大，远处细节明显得到了加强。</p><h4 id="虚拟纹理"><a href="#虚拟纹理" class="headerlink" title="虚拟纹理"></a>虚拟纹理</h4><p>读到这里，相信你已经对纹理映射有了更清晰的认知。在现实游戏开发中，为了有更好的视觉体验，往往会使用更大的纹理加Mipmap的形式来表现物体，但这就会给带<strong>显存宽带</strong>来压力。为了解决这一问题，出现了<strong>虚拟纹理</strong>这一解决方案。</p><p>虚拟纹理的思路与LOD Mesh的思路比较接近，就是不会一次性将整张巨大的纹理加载到内存中，而是根据实际需要，将需要的部分进行加载。实现方法就是，将每层Mip拆分成大小一致的tile（虚拟纹理），根据某种规则，映射到内存中存在的纹理（<strong>物理纹理</strong>）中。当视野发生变化的时候，物理纹理中的一部分会发生变化，重新映射相应虚拟纹理中的内容。</p><p><img src="https://s1.ax1x.com/2020/06/22/N8zH1A.jpg" alt="N8zH1A.jpg"></p><p>关于虚拟纹理，<a href="https://zhuanlan.zhihu.com/p/138484024">这篇文章</a>十分推荐阅读，以及关于<a href="https://zhuanlan.zhihu.com/p/147213120">虚幻4中虚拟纹理的源码导读</a>。</p><h3 id="纹理应用"><a href="#纹理应用" class="headerlink" title="纹理应用"></a>纹理应用</h3><p>纹理在实际应用当中，远不止贴上“一层皮”那么简单。通过各种各样的纹理，我们可以实现出更加逼真、高效的表现来。下面简要介绍一些比较常见的纹理贴图应用。</p><p>更多详细的介绍，请参考<a href="https://zhuanlan.zhihu.com/p/27339998">这篇文章</a>。</p><h4 id="Bump-Noramal-Map"><a href="#Bump-Noramal-Map" class="headerlink" title="Bump/Noramal Map"></a>Bump/Noramal Map</h4><p>有的时候，纹理并不只是用来存储颜色，也可以存储一些高度、法线信息，用来在一个光滑表面来展现出一些细节上“不平整”的trick效果。</p><p>我们管这种贴图叫 <strong>凹凸贴图</strong> 或 <strong>法线贴图</strong>。</p><p><a href="https://imgchr.com/i/N8zqXt"><img src="https://s1.ax1x.com/2020/06/22/N8zqXt.md.jpg" alt="N8zqXt.md.jpg"></a></p><p>一般的法线贴图，都会呈现出一种偏蓝色的效果。这是因为平面上的法线向量为(0， 0， 1) ，正好对应 <em>RGB</em> 中的 <strong>B</strong> 通道。法线贴图只是对不同平面上的法线进行轻微的扰动，造成光线反射到人眼（摄像机）的方向发生变化，从而营造出一些明暗变化的细节表现。</p><p>下面是没有使用法线贴图与使用法线贴图的对比效果。</p><p><img src="https://s1.ax1x.com/2020/06/22/N8zj78.jpg" alt="N8zj78.jpg"></p><h4 id="Light-Map"><a href="#Light-Map" class="headerlink" title="Light Map"></a>Light Map</h4><p>对于一些相对静态的场景，实时地去计算复杂的全局光照无疑是十分影响性能的，尤其是在移动平台。于是，会先离线渲染出一张场景的光照贴图，里面包含了当时场景复杂的光照计算结果，通过与场景的漫反射贴图相结合来生成一个不错的光影表现效果，并且节约了性能开销。唯一的缺点就是，如果镜头或光源在Runtime会发生动态变化，很容易穿帮。</p><h4 id="Cube-Map"><a href="#Cube-Map" class="headerlink" title="Cube Map"></a>Cube Map</h4><p>立方体纹理由6块方形的纹理组成，分别对应一个立方体的6个面。立方体贴图有一个非常重要的作用，就是可以根据一个方向向量来进行采样。</p><p>常见的一种做法，利用Cube Map制作出一张环境光的反射贴图，并将一个模型包起来，根据模型表面的法线采样Cube Map对应的纹素点，将得到的颜色与模型Diffuse贴图的颜色结合计算，得到一个相对逼真的模拟环境光反射效果。模型在这个Cube下的自旋转，表面的光影也会随着发生相应的变化。只不过与使用烘焙出来的Light Map类似，当镜头或光源发生变化时，还是容易出现穿效果，也只是一种降低性能开销的取巧办法。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>手游开发中渲染优化的三个要素</title>
      <link href="/2020/05/21/2020-05-21-mobile-optimized-3factor/"/>
      <url>/2020/05/21/2020-05-21-mobile-optimized-3factor/</url>
      
        <content type="html"><![CDATA[<p>评价一款游戏的性能好坏，我们通常会用到<strong>帧率</strong>（每秒钟的渲染帧数）作为主要参考指标。当然，手游这块功耗也是一个重要因素，但主要还是看帧率。像MOBA、FPS类的游戏，帧率肯定是越高越好，出于功耗与显示设备的限制，一般跑满也就在60fps左右。而像其他的棋牌、放置类游戏，帧率只要有30fps就足够了。</p><p>性能优化要谨遵<strong>二八原则</strong>：<em>20%的代码影响80%的性能瓶颈</em>。因此要合理地找出性能瓶颈所在，避免负优化。下面就三个比较常见的方面：<strong>bandwidth</strong>、<strong>drawcall</strong>、<strong>overdraw</strong>（fillrate）来分别阐述渲染阶段是如何造成性能瓶颈以及对应的解决办法。</p><span id="more"></span><h3 id="Bandwidth"><a href="#Bandwidth" class="headerlink" title="Bandwidth"></a>Bandwidth</h3><p>移动端的GPU设计之初，优先注重的肯定是功耗问题，然而在实际渲染一帧图像的时候，对功耗影响最大的因素就是<strong>带宽（bandwidth）</strong>。</p><p>为什么会是带宽呢？</p><p>这是因为出于空间的考虑，手机芯片的设计上采用了SoC架构，因此内存与显存实际上是共享在一块物理内存上的，在OpenGL ES规范中，内存与显存中的数据却不能共享。在有限带宽的前提下，我们不妨计算一下，一台分辨率为1920*1080的移动设备，按60帧率来算，每秒钟1次overdraw产生的数据量为：</p><blockquote><p>1920 * 1080 * 32 * 60 / (1024 * 1024) = 3.7 Gb</p></blockquote><p>如果遇到了大量的半透明物体或是粒子特效，那么数据量上可能会成倍的增长。</p><p>如此大量的数据存储在显存的FrameBuffer中，GPU要以高昂地代价频繁地去显存访问FrameBuffer里的数据，这显然是很难接受的。因此在移动端的显卡硬件上，想到了一种优化方式，就是将FrameBuffer拆分成不同的小块(tile)，每次可以先将这一小块的数据放到访问速度更快的On-Chip Memory中去，GPU会先从tile中一块块地去进行渲染，等整体渲染完成之后，再将数据搬回显存上。</p><p>我们将这种模式称为 <strong>TBR（Tile Base Rendering）</strong>。</p><p><img src="https://s1.ax1x.com/2020/05/21/YHgLC9.png" alt="TBR渲染管线"></p><p>然而在TBR模式下，可能存在着这样的一个问题，如果对于CPU每一次传来的绘制命令都进行渲染的话，那么GPU必定会频繁、大量地对tile数据进行搬迁操作，这显然是不可接受的。为了解决这个问题，TBR一般的策略是：对于CPU提交的Draw Call请求，先只做顶点处理，将Vertex Shader计算的结果暂存到一个叫 <strong>FrameData</strong> 的地方。等到执行 <strong>Swap Buffer</strong> 的时候，再对整个数据做光栅化，进行绘制。</p><p>既然是等所有的FrameData数据处理好后一次性进行绘制，GPU硬件上便进一步做了些延迟渲染相关的优化。例如iOS上的PowerVR，专门有一个叫 ISR 的硬件，会去处理FrameData中那些诸如深度测试、模板测试没有通过的数据，尽可能地只去渲染那些最终影响FrameBuffer的物体。</p><p>我们将这种模式称为 <strong>TBDR（Tile Base Deffered Rendering）</strong>。</p><p>基于移动端GPU特有的架构模式，需要我们做哪些优化方面的事情或是注意事项呢？</p><ul><li>使用压缩的纹理格式，如ETC、PVR等</li><li>打开Mipmap（内存与带宽的权衡）</li><li>减少Shader中的采样次数，尽量合并一些通道图</li><li>控制总顶点数量</li><li>不要频繁地切换FrameBuffer（后处理效果）</li></ul><h3 id="Drawcall"><a href="#Drawcall" class="headerlink" title="Drawcall"></a>Drawcall</h3><p>手机上CPU与GPU的关系，就好像客户端与服务端的CS架构。所谓Drawcall，可以理解为Client端的CPU向Server端的GPU发送的一次绘制命令，同时会传递需要被渲染的图元列表。现代GPU就为了<strong>高并发</strong>处理数据而生的，一般Drawcall的绘制数据计算起来应该还是绰绰有余。但由于CPU传递的渲染数据得通过PCI-E总线才能传到GPU显存中的全局存储区域，频繁且大量地提交绘制相对简单的绘制命令，会造成GPU端的“ <em><u>产能过剩</u></em> ”，CPU无法及时提供渲染数据而造成性能瓶颈。</p><p>与此同时，TBR架构下优化过的GPU，会先将顶点数据存储到FrameData队列，如果Drawcall数量过多，且顶点数量巨大，万一FrameData承装的内存放不下了，就得先将数据移动到别处，进而大大降低了访问速度。这也是我们需要控制DrawCall数量和顶点数的一个重要原因。</p><p>游戏开发中，常见的降低Drawcall的方式，无非以下几种：</p><h5 id="动态合批"><a href="#动态合批" class="headerlink" title="动态合批"></a>动态合批</h5><blockquote><p>在每一帧都对需要的网格进行合批处理，这样的好处就是合批的物体仍然可以各自移动，但是必须使用同一个材质。当所需合批的顶点数过多时，其实会对CPU产生额外的计算开销。因此在做动态合批的时候，通常会有顶点数的限制，需要根据实际需要做好取舍。</p></blockquote><h5 id="静态合批"><a href="#静态合批" class="headerlink" title="静态合批"></a>静态合批</h5><blockquote><p>只进行一次合批处理，生成一个大的网格，性能优于动态合批，但没有动态合批灵活（只能作用于静态物体），并且会有较高的内存占用。</p></blockquote><h6 id="Shader-LOD"><a href="#Shader-LOD" class="headerlink" title="Shader LOD"></a>Shader LOD</h6><blockquote><p>根据机型或摄像机距离，使用不同的材质shader，尽可能地降低细节表现，去除不必要的渲染Pass以及计算开销。</p></blockquote><h5 id="遮挡剔除"><a href="#遮挡剔除" class="headerlink" title="遮挡剔除"></a>遮挡剔除</h5><blockquote><p>常见于大世界场景的游戏中，对于摄像机可视范围之外的物体可以进行视锥体剔除，但是可视范围内的那些已经被遮挡住了的物体，可能仍然会去进行绘制，造成不必要的性能损耗。</p></blockquote><h3 id="Overdraw"><a href="#Overdraw" class="headerlink" title="Overdraw"></a>Overdraw</h3><p>对需要绘制的物体进行排序，是游戏引擎规避性能开销的一种常见手段。非透明物体相对摄像机由近及远地排序绘制，可以有效剔除那些深度测试不通过的片元。但对于那些未被遮挡（深度测试通过）的<strong>透明物体</strong>，由于需要开启混合计算，因此在Early-Z阶段也没法剔除掉那些背后的图元数据，这就造成了同一个像素的多次(过度)绘制，即我们常说的 <strong>Overdraw</strong> 。</p><p>GPU中跟Overdraw有关的指标可以参考<strong>像素填充率</strong>，即每秒所能渲染的最大像素数量。在确保带宽没有遇到性能瓶颈后（改用压缩纹理格式），如果降低设备分辨率后，帧率一下子上去了，那么很可能就是像素填充率遇到了瓶颈。这时候就需要看看Overdraw是否在一个合理的范围内，是否有优化的空间。</p><p>实际的游戏开发中，最常见的Overdraw大户莫过于<strong>粒子特效</strong>了。美术同学在制作粒子特效的时候，往往会为了追求细节效果而忽略掉Overdraw的问题。大量的透明粒子相叠加，造成的性能开销是十分可怖的。为此，我们最好在立项之初就设定好一些粒子特效的制作规范，或是一些建议要求来约束美术设计粒子效果。</p><blockquote><ol><li>一个复合粒子系统（如爆炸），子特效尽量不要超过5个（叠加过曝也应考虑优化）</li><li>粒子所占的屏幕面积尽量不要过大，可以考虑使用Mesh来替换</li><li>纹理中透明不可见的部分尽可能地少</li></ol></blockquote><p>为了照顾低端机型，我们可以对粒子特效采取分级的策略，等级越低，特效表现越简单，同时也可以从粒子数量、运算模块来进行精简。如果还是不能满足性能要求，也可以考虑改用帧动画来替代粒子特效。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>聊聊ECS架构与实际应用</title>
      <link href="/2020/04/30/2020-04-30-talk-about-ecs/"/>
      <url>/2020/04/30/2020-04-30-talk-about-ecs/</url>
      
        <content type="html"><![CDATA[<p>ECS近年来已然成为游戏开发中比较热门的一种架构模式，最近被大家所熟识并热烈讨论，还是源于GDC2017，《守望先锋》针对它们的ECS架构进行的一次技术分享。针对FPS，MOBA这类的竞技游戏，ECS架构有着得天独厚的优势。下面我们先简单地介绍一下什么是ECS。</p><ul><li>E – Entity 实体，本质上是存放组件的容器</li><li>C – Component 组件，游戏所需的所有数据结构</li><li>S – System 系统，根据组件数据处理逻辑状态的管理器</li></ul><span id="more"></span><p>这里需要强调一下，Componet组件只能存放数据，不能实现任何处理状态相关的函数，而System系统不可以自己去记录维护任何状态。说的通俗点，就是<u><strong>组件放数据，系统来处理</strong></u>。这么做的好处，就是为了尽可能地让数据与逻辑进行<strong>解耦</strong>。与此同时，一个良好的数据结构设计，也会以增加<strong>CPU缓存命中</strong>的形式来提升性能表现。但我认为，推动ECS流行的更深层次原因，是它的解耦理念，性能上还只是其次。</p><p>试想一下，你在开发一款多人实时在线竞技游戏，无论是吃鸡也好，农药也罢，日益堆积的<strong>变动需求</strong>与越来越多的<strong>状态维护</strong>肯定是开发人员所需面对的主旋律。也许游戏设计之初，策划会信誓旦旦地跟你说，咱们要整个5v5对战的MOBA游戏，就跟王者农药差不多，不过咱们牛逼的地方在于英雄可以变成汽车，就像变形金刚那样：</p><p><img src="https://s1.ax1x.com/2020/04/29/JTbytA.gif" alt="1"></p><p>假设你用面向对象设计中的”类-继承“模式，肯定会优先设计出一个“英雄”类来，它可能会有不同的技能和武器，当然这需要通过策划来配置，我们则根据这些不同的配置数据，来实例化出一个个独立的英雄。同时，这个类还要包含“变身”的功能，变成汽车后，“人”的一些行为会被限制，比如无法开枪射击，但是移动速度会大大增加，物理耐性提升等等。</p><p>当你辛辛苦苦设计好满意的游戏架构后，策划又兴冲冲地跑过来，阐述他的新点子：英雄变成汽车状态后，应该有不同的形态表现，有的2个轮子的、4个轮子的，也有履带式的，最好还能支持没有轮子的概念车！在策划看来，这种仅仅调整一些配置性的东西，实现起来难度应该不大。但是对于开发者来说，移动的动作，车轮的印记特效等等，都需要重新考虑一番，好好地重构。</p><p>没过几天，策划又鬼魅般地出现，提出了新的需求：我体验了下游戏原型，只是变身汽车的话游戏画面不够立体，打击感也不强，你看能不能再加个变身飞机的机制，最好能海陆空全方位战斗，就像这样婶儿的：</p><p><img src="https://s1.ax1x.com/2020/04/29/JTb6fI.gif" alt="2"></p><p>没办法，还得继续扩展这个英雄类，让它的功能越来越“强大”，即使我们的内心几近崩溃的边缘。</p><p><img src="https://s1.ax1x.com/2020/04/29/JTbDTH.gif" alt="3"></p><p>又过了几天，策划再次出现，还未说话，卒。</p><p><img src="https://s1.ax1x.com/2020/04/29/JTbgpt.gif" alt="6"></p><p>当然，上面举的例子有很多玩笑的成分在里面，但如果你也是位游戏开发者的话，是不是会产生共鸣，有种似曾相识的感觉？策划的专业程度或许是一方面，但游戏的<strong>版本迭代</strong>与<strong>不断试错</strong>都是客观存在的事实，是无法逃避的。随着需求的不断累加，最初的那个“英雄类”会越来越臃肿。倘若你的项目中有多个程序员进行协作开发，那么恭喜你，代码的维护成本会指数级的增加！每个人都必须对英雄的方方面面了若指掌，否则一个不当的改动就可能造成毁灭性的灾难。</p><p>这个时候，ECS架构就体现出了它的优势。</p><p><img src="https://s1.ax1x.com/2020/04/29/JTb21P.gif" alt="7"></p><p>与传统的“类-继承”奉行的“我是什么”不同，基于组件化的ECS架构更强调的是“我有什么”，是一种<strong>组合优先</strong>的编程模式。使用组合而非继承，会使你的代码更具灵活性。还是上面的例子，针对游戏的玩法，我们会构建出一个英雄的Entity实体类，它更像一个空盒子，可以在创建英雄Entity实例的时候赋予它一个ID作为唯一标识。当我们将这个实体放到world下，也许什么也看不见，什么也做不了，这是因为它现在还什么数据都没有。此时就需要根据游戏的需求，来设计出不同的组件填充到这个实体当中。注意，应尽可能地保证组件设计上的<strong>扁平化</strong>，会让你的模块结构更加清晰，也大大增加了CPU缓存命中的概率。</p><p>举个例子，常见的组件包括而不仅限于</p><ul><li>渲染组件 ：英雄的顶点、材质等数据，保证我们能正确地渲染到world中</li><li>位置组件 ：记录着实体在这个world的真实位置</li><li>特效组件 ：不同的时机，可能会需要播放不同的粒子特效以增强视觉感受</li></ul><p>此外，根据策划的各种奇葩需求，还可以衍生出不同的功能性组件，本质上都是数据的集合，之后会交由 System 来进行各种状态修改与逻辑计算。比如，想要一个英雄既能变成汽车又能变成飞机，我们可以设计出 Wheel 和 Wing 两个组件，存储数据的同时也表明不同实体的对应功能或身份。当然对应着的是处理该组件的System，一个 FlightSystem 可以去关注那些持有 Wing 的实体。确切点说，FlightSystem 其实只需要关注 Wing 组件就足够了，它不应该关心是哪个实体持有这个组件，只要能修改 Wing 的状态就足矣。</p><p>这样，就实现了我们经常说的<strong>解耦</strong>。</p><p>将复杂的游戏拆解成不同的逻辑处理单元 (System) ，而每个逻辑处理单元只关心那些向它注册监听的数据，其他数据一概不管。并且最主要的是，System 是不保存状态的，Component 才是状态的真正持有者。刚开始的时候，也许会很不适应，总想着在 System 里加点什么标识，好方便地进行状态回溯或者复用。这时应该警惕起来，你所设计的   System 职责是否单一，组件持有的数据是否过于复杂。<u><strong>将一个复杂的模块拆解成若干个相对简单的单元</strong></u>，不失为明智的选择。</p><p>下面就是我们基于ECS而设计的新的游戏架构。</p><p><img src="https://s1.ax1x.com/2020/04/29/JTbB0e.png" alt="4"></p><p>然而，现实总是残酷的。如果一个游戏真要这么简单，或许ECS也就没什么存在的价值了。仅就《守望先锋》分享所知，它们游戏中光 System 就上百个，并且为了保证 System 不保存状态，在游戏帧更新时，System 执行的时序就有了限制。并且很多情况下，很多System关心的组件只有一个（如输入事件），于是就有了<strong>Singleton Component</strong>。个人觉得，由于不同游戏的不同特质，某些情况下都很难去严格遵循ECS的架构约束，但毕竟架构是为人服务的，而不仅仅是束缚。在我们深刻理解了ECS的思想后，针对实际需要来做一些变通也是未尝不可的。</p><p>就拿我参与开发的一款轻MOBA类的多人对战游戏为例，采用的网络通讯方式是protobuf加状态同步，伤害、状态等判定结果几乎都是放在服务器端来处理，客户端主要就是根据每一帧接收的网络消息来处理相应的数据、更新状态。由于客户端使用的语言是<strong>Lua</strong>，因此会使用一个table数据结构来保存游戏中注册的 System 实例，在帧循环遍历这个注册表，按照顺序依次执行每个 System 的<strong>Update</strong>函数。System 会处理自己内部维护的组件池，里面放的是注册进来希望被处理的组件，从而根据这些组件的数据来进行一些逻辑上的操作。</p><p>解析protobuf数据后，每条协议消息发来的数据其实就是组件所要更新的，但由于服务器端并没有采用ECS这种设计模式，数据设计上也肯定会有些出入的地方，于是需要客户端来解析转换下。为此，引入了<strong>Driver</strong>的概念。首先，会有若干个表格来存放我们创建了的不同Entity 实例，每个Entity都会持有一个ID。服务器端下发的消息中总会包含某些实体ID，这样处理不同逻辑的 Driver 就会根据这些ID来找到它所需修改数据的Entity，再从Entity找出相关的 Component 组件，将proto消息里的数据更新给这个组件即可，剩下的工作就交给 System 了。</p><p>至此，我们的ECS设计变种成了这个样子：</p><p><img src="https://s1.ax1x.com/2020/04/29/JTb0mD.png" alt="5"></p><p>上述设计中，由于多了一层Driver，并且游戏使用的是<strong>状态同步</strong>机制，因此帮助 System 分担了很多工作。System 仅仅是批量处理 Component 状态的管理者，每一帧遍历系统组件池里的所有组件 (此时的组件已经是 Driver 更新好数据了的) ，我们也可以根据自己的需要来设定刷新间隔，对于一些不需要在每个帧刷新都执行 Update 函数的 System ，可以降低它们的更新频率从而节约一些性能开销。而 Driver 层面，只是数据的一道“搬运工”，负责更新给 System 能够识别的组件的持有数据。</p><p>当所在团队改用ECS后，起初都很不习惯这种新的编程模式，总会不知不觉中切换回“类-继承”的编程思路。但随着项目的推进，ECS所带来的一些优势变得愈发明显。首先，就是<strong>降低了团队协作成本</strong>。往昔的项目经历中后期时，总会出现某些又臭又长的 <strong>God Class</strong> ，甚至会出现一些功能重复的模块，同一个功能的函数被实现了两次！这种情境下，代码的维护成本可想而知。而在ECS编程模式下，每名开发人员，只需要关心自己负责的模块即可，System 很好地隔离模块之间的耦合。</p><p>ECS也并非尽善尽美，随着系统不断地开发与扩展，会发现难免有时 System 要处理的数据过于复杂，很难只用一个单一组件就能表示，或是之前所说的只有一个 Component 会被 System 监控的Singleton情况十分常见。这就考验开发者的权衡取舍能力：如果一味细化 System 的种类，虽能保证模块与组件数据之间的解耦，但却无形中增加了 System 的维护成本，使得原本比较简单的逻辑变得复杂起来，难以维护。另一种做法是，建立组件之间的关联，可以是组件内部持有另一个组件的指针，也可以是几个组件组合成一个新的组件。但这样做就牺牲掉了组件设计上的<strong>扁平化原则</strong>。</p><p>综上所述，世界上没有两全其美的好事，我们经常要去做决策、去权衡每种做法的利弊。一味刻板地循规蹈矩也是不可取的，越来越多的团队开发衍生出了新的ECS变种。但只要我们真正地理解了ECS的主旨与精髓，不断探索与改进，找到适合自己项目的最佳平衡点，它一定会成为助你高效开发的利器。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用PhysX构建简单的物理系统</title>
      <link href="/2018/08/15/2018-08-15-build-physics-system/"/>
      <url>/2018/08/15/2018-08-15-build-physics-system/</url>
      
        <content type="html"><![CDATA[<h3 id="PhysX物理引擎"><a href="#PhysX物理引擎" class="headerlink" title="PhysX物理引擎"></a>PhysX物理引擎</h3><p>PhysX是一套由AGEIA公司开发的物理运算引擎(后被NVIDIA收购)，简而言之，就是令虚拟世界中的物体运动符合真实世界的物理定律，以使游戏更加富有真实感。PhysX可以由CPU计算，但其程序本身在设计上还可以调用独立的浮点处理器（例如GPU和PPU）来计算，也正因为如此，它可以轻松完成像流体力学模拟那样的大计算量的物理模拟计算。</p><p>目前最火热的两款商业游戏引擎Unreal和Unity都采用PhysX作为它们的物理引擎来模拟物理计算，并且PhysX已经于2014年宣布开源，现在在Github上就能免费下载全部源码。不过需要注册NVIDIA的开发者账号，并注册加入其在Github上的组织才能下载源码。</p><p>具体方法请参考<a href="https://developer.nvidia.com/physx-source-github">这里</a>。</p><span id="more"></span><h3 id="物理系统"><a href="#物理系统" class="headerlink" title="物理系统"></a>物理系统</h3><p>所谓物理系统，就是针对物理引擎做出的进一步封装，方便开发者添加和使用需要的物理特性。如果你的游戏引擎是基于组件式的架构的话，那么一个简单的物理系统可能需要以下两个基本的物理组件：__Rigidbody__、__Collider__。并且需要一个PhysicsManager来管理物理引擎的初始化、物理模拟和相关资源的释放等。其中每个Collider组件都可以添加物理材质，它仅仅是用来设定物理碰撞时的动静态摩擦力以及反弹系数等数值。</p><p>其实物理系统还可以拆分诸多个子系统，比如__布料系统__、__布娃娃系统__、__物理粒子系统__和__Vehicle车辆系统__等。但这里不会做过多的详细介绍，接下来仅会对Rigidbody和Collider的实现原理进行分析说明。</p><p>具体的物理系统架构：<br><img src="http://7xlmp2.com1.z0.glb.clouddn.com/2018-08-15%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F.png" alt="01"></p><h3 id="Rigidbody组件"><a href="#Rigidbody组件" class="headerlink" title="Rigidbody组件"></a>Rigidbody组件</h3><h4 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h4><p>在游戏场景中，可能会有许许多多的游戏元素，但哪些需要去表现一些物理特性（也就是被物理引擎去模拟计算）呢？这就需要用到Rigidbody组件，例如在Unity中，如果一个GameObject包含Rigidbody组件，那么就可以认为它会受到物理世界的模拟影响，比如自由落体运动。</p><p>本质上就是在Rigidbody中维护着一个PxRigidActor类型的指针，它会被添加进PhysX的物理场景中，由物理引擎去模拟计算每一个固定时长帧下的刚体状态变化。在渲染的时候，我们再根据物理引擎计算得出的Rigidbody位置、旋转信息，附加设置到对应GameObject的Transform组件上即可。</p><p>下面是PxRigidActor类的继承关系图：<br><img src="http://7xlmp2.com1.z0.glb.clouddn.com/2018-08-15-physx_actor_tree.png" alt="02"></p><p>由上图可以发现在PxRigidActor下面，还会继续派生出PxRigidDynamic和PxRigidStatic来。实际上在Rigidbody组件中，会更多地用到PxRigidDynamic的特性，比如质量、阻力、速度等等。而PxRigidStatic更多的是为那些只有Collider组件而没有Rigidbody组件的静态物体所使用，这类静态物体不会受任何力的影响，但会参与到碰撞当中去，并能够给其他有Rigidbody组件的物体以影响。</p><h4 id="质量属性"><a href="#质量属性" class="headerlink" title="质量属性"></a>质量属性</h4><p>一个dynamic actor所需的质量属性包括：质量，转动惯量和质心。在PhysX中，计算质量属性的方式是调用__PxRigidBodyExt::updateMassAndInertia()__函数，也可以通过__PxRigidBodyExt::setMassAndUpdateInertia()__来改变刚体的质量分布。</p><p>每个PxRigidActor可以动态地维护1到n个__PxShape__，每当shape的增加或减少，我们都应去更新刚体的质量分布以获得更加逼真的物理表现。而每个PxShape的指针，我们会放到Collider组件中去维护，在之后会做详细地介绍。</p><h4 id="运动学刚体"><a href="#运动学刚体" class="headerlink" title="运动学刚体"></a>运动学刚体</h4><p>还是拿Unity举例子，当一个Rigidbody组件被设置为IsKinematic时，表示该刚体不再受任何力的作用，但是可以对其他动态刚体施加作用力。刚体实现设置为Kinematic很简单，只需要调用:</p><pre><code>PxRigidBody::setRigidBodyFlag(PxRigidBodyFlag::eKINEMATIC, true);</code></pre><p>将刚体设置为Kinematic通常是为了希望可以人为地去改变物体的Transform而不是通过物理引擎的模拟计算结果。但人为修改Transform时，应注意区分__PxRigidDynamic::setKinematicTarget()__和__PxRigidActor::setGlobalPose()__。当使用setGlobalPose()时，仅仅会将actor移动至合适的位置，而不和其他物体发生交互。特别注意的是，Kinematic的刚体使用setGlobalPose()并不会推开经过路径上的其他动态刚体。</p><p>如果两个刚体都是Kinematic的，则不会产生碰撞效果，但是可以请求获得企图发生碰撞的两个物体的相关碰撞信息， <strong>PxSceneFlag::eENABLE_KINEMATIC_PAIRS</strong> 或 <strong>PxSceneFlag::eENABLE_KINEMATIC_STATIC_PAIRS</strong> 被设置上即可。</p><h3 id="Collider组件"><a href="#Collider组件" class="headerlink" title="Collider组件"></a>Collider组件</h3><h4 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h4><p>Collider组件主要是为了封装PxShape，之前也有说过，每一个物理世界中的物体(PxRigidActor)可能会对应多个PxShape，但是Collider组件只会维护一个PxShape，表示这个碰撞体的指定形状。由于组件化的灵活机制，可能某一个子GameObject只有Collider组件而没有Rigidbody组件，因此要向上查找其Parent GameObject是否持有Rigidbody组件，如果有的话则将该Collider维护着的PxShape指针attach到找到的Rigidbody组件持有的PxRigidActor上（记得需要更新质量分布属性）。</p><p>具体架构如下图：<br><img src="http://7xlmp2.com1.z0.glb.clouddn.com/2018-08-15-relation_colliders_pxshape.png" alt="03"></p><h4 id="Shapes"><a href="#Shapes" class="headerlink" title="Shapes"></a>Shapes</h4><p>在PhysX中，使用PxShape来描述刚体的空间范围和碰撞属性，当我们创建PxShape的时候，需要先构建PxGeometry和PxMaterial，构建PxGeometry的派生类对象，常见的包括：<strong>Box__、__Sphere__、__Capsule__、__Convex Meshes</strong> 和 <strong>Triangle Meshes</strong> 等。其中TriangleMesh类型的几何体不支持Simulation Shape附加在动态刚体上，除非该刚体被配置为Kinematic。根据不同的Geometry类型，我们可以封装成不同的组件并继承自Collider，一一对应，具体包括：<strong>BoxCollider__、__SphereCollider__、__CapsuleCollider</strong> 和 <strong>MeshCollider</strong> (统一管理Convex和Triangle)。</p><p>每个子Collider实现中，要去管理对应Geometry所需的特征数据，如SphereCollider得去维护Sphere Geometry的半径等，剩下的具体计算只需要交给PhysX。无论PxShape对应什么形状，其具体Transform都是位于PxRigidActor坐标系下的，因此我们只能修改PxShape的相对位置。世界坐标系下的Transform信息，应交给PxRigidActor来关心。动态刚体的运动轨迹最好由PhysX计算完成，而静态刚体则可以通过调用 <strong>setGlobalPose()</strong> 函数来进行设置。</p><blockquote><p><strong>特别注意</strong> :<br><em>1. 在构建或更新Geometry的时候，需要考虑Collider组件对应的GameObject缩放系数</em><br><em>2. 在PhysX中，Capsule是沿X轴方向水平拉长的，如果想做成类似Unity那种沿Y轴方向的效果，需要手动旋转90度</em></p></blockquote><h4 id="物理材质"><a href="#物理材质" class="headerlink" title="物理材质"></a>物理材质</h4><p>在现实世界中，不同的物体发生碰撞总会产生不同的运动效果。比如汽车在冰面上行驶和在水泥地上行驶的摩擦阻力肯定是不同的。在PhysX中封装了PxMaterial来描述不同物体在物理世界中的个体差异。在构建PxShape时，除了PxGeometry外，PxMaterial也是必须的。</p><p>创建一个PxMaterial很简单，只要调用静态函数__PxMaterial::createMaterial()<strong>并传入__静态摩擦力系数__、__动态摩擦力系数</strong> 和 <strong>反弹系数</strong> 就可以了。同时PxMaterial还支持设置摩擦力结合模式和反弹结合模式，可根据发生碰撞的两个物体的物理材质系数，取平均值、最大值和最小值等。</p><h3 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h3><p>一般的碰撞检测算法，都要分2个阶段：<strong>Broad Phase</strong> 和 <strong>Narrow Phase</strong> 。其中Broad Phase主要用于构建场景中碰撞盒的BVH(Bounding Volume Hirerarchy)。通过构建BVH，来配对(潜在)碰撞盒。而在Narrow Phase中，会对Broad Phase已确定的碰撞盒进行二次检测，确定最终的碰撞结果。在PhysX中，Broad Phase主要的算法包括 <strong>SAP(Sweep And Prune)</strong> 和 __MBP(Multi Box Pruning)__。具体关于SAP的介绍，可以参考<a href="https://en.wikipedia.org/wiki/Sweep_and_prune">这里</a>。</p><p>使用MBP算法，同时会引入Regions的概念。Regions就是世界坐标系下的AABB包围盒体积空间，该空间外的所有物体不会进行碰撞检测，理想情况下应该覆盖到整个游戏空间，并且最大数量不要超过256。出于对性能的考虑，尽量不要让不同的Regions相互重叠，两个Regions的AABB仅仅触碰并不算重叠。</p><p>创建物理场景时，可以指定一个 <strong>PxSimulationFilterCallback</strong> 的回调函数指针。该回调将会在场景中所有的shape pair的包围盒第一次相交时执行，并根据回调的返回值来确定接下来的行为。每一个PxShape对象中都持有一个 <strong>PxFilterData</strong> 类型的成员变量，用128bit的数据来指定跟Collision Filter有关的信息，这些信息都会在PxSimulationFilterCallback回调中以PxFilterData类型的参数传递进来，同时回调参数还包括一块指定大小的内存，可以用来传递更多的数据信息，需要在构建PxSceneDesc时指定 <strong>filterShaderData</strong> 和 <strong>filterShaderDataSize</strong> 。</p><p>利用这一灵活的特性，我们可以方便地实现__动态__设置刚体是否支持 <strong>CCD(Continuous Collision Detection)</strong> 和__按层过滤碰撞机制__。这两个功能可以有效地提高物理模拟的性能，减少一些不必要的计算消耗。每一个PxFilterData只包含4个int类型的成员(word0~word3)，我们可以先用word3来表示发生碰撞的对应shape是否支持CCD，具体的设置需要放到Collider组件中，查找其对应依附的Rigidbody组件并获取其CCD支持状态。具体代码如下:</p><pre><code>PxU32 filterFlags0 = (filterData0.word3 &amp; 0xFFFFFF);PxU32 filterFlags1 = (filterData1.word3 &amp; 0xFFFFFF);bool ccdCondition0 = (filterFlags0 &amp; CCD_MODE::DYNAMIC) &amp;&amp; !(filterFlags1 &amp; CCD_MODE::OFF);bool ccdCondition1 = (filterFlags0 &amp; CCD_MODE::NORMAL) &amp;&amp; (attributes1 &amp; PxFilterObjectType::eRIGID_STATIC);if (!(k0 &amp;&amp; k1) &amp;&amp; (ccdCondition0 || ccdCondition1))&#123;    pairFlags |= PxPairFlag::eSOLVE_CONTACT;    pairFlags |= PxPairFlag::eDETECT_CCD_CONTACT;&#125;pairFlags |= PxPairFlag::eDETECT_DISCRETE_CONTACT;</code></pre><p>其中pairFlags是回调的引用参数，用于输出碰撞对的状态。</p><p>至于按层过滤碰撞机制，实现方式类似，不过要用到filterShaderData。在filterShaderData中存储着一个长度为32的uint32_t数组，里面每一个int的每一个bit用来表示不同层之间的碰撞关系(0表示不支持碰撞，1表示支持碰撞)。因此这就限制了层的最大上限只能是32，实际上Unity的实现也是如此。与此同时，我们可以使用PxFilterData.word0来标识对应Collider的隶属层的索引，通过位运算来计算出是否支持产生碰撞，不支持则直接函数返回 <em>PxFilterFlag::eSUPPERESS</em> 。代码片段如下：</p><pre><code>PxU32 shapeGroup0 = (filterData0.word0 &amp; 0xFFFFFFFF);PxU32 shapeGroup1 = (filterData1.word0 &amp; 0xFFFFFFFF);uint32_t* groupCollisionFlags = (uint32_t*)constantBlock;if ((groupCollisionFlags[shapeGroup0] &amp; (1 &lt;&lt; shapeGroup1)) == 0)&#123;    return PxFilterFlag::eSUPPRESS;&#125;</code></pre><p>其中constantBlock就是指在构建物理场景时传入的层碰撞状态数组。</p><h3 id="固定步长刷新"><a href="#固定步长刷新" class="headerlink" title="固定步长刷新"></a>固定步长刷新</h3><p>渲染，表现的只是游戏时间中的一瞬间，通常不需要关心距离上次渲染过去了多少时间，因此会放到变时步长刷新中。但是物理模拟运算不同，它需要一个合理的固定步长刷新机制，来使得物理表现更加逼真、稳定。也就是说，我们以固定时间步长来更新模拟物理计算，但渲染的时间点却是随机的，让我们看看时间线：</p><p><img src="http://7xlmp2.com1.z0.glb.clouddn.com/2018-08-15-timeline-with-update.png" alt="04"></p><p>如上图所见，时间线上端的“更新”表示一次物理模拟运算，它们之间的间隔是相同而紧凑的，但是渲染发生的位置是不固定的并且通常频率会低于更新。因此，我们并不能保证总在更新的时间点进行渲染，观察下第三次和第四次渲染，它们就是发生在两次更新之间。试想一颗子弹横穿屏幕，首次更新它在屏幕的左侧，而第二次更新它将移动到屏幕的右侧，如果渲染在两次更新之间进行，并且只根据前一次更新结果的话，子弹会被渲染到屏幕的左侧，而我们更希望子弹出现在屏幕的中间某一位置。</p><p>为了更逼真的物理运动表现，或减少一些不必要的抖动问题，就要求我们去做一些额外的差值运算。在Unity的刚体组件中，提供了设置Interpolate来选择差值方式，其中Interpolate表示根据前一固定帧来进行差值计算，Extrapolate则表示预测下一固定帧的位置来进行差值计算。</p><p>所需的差值计算方式可以交给Rigidbody组件来记录，除了Interpolate和Extrapolate之外，当然也可以什么都不做，即None。假设用于渲染的变时步长回调为update()，用于物理模拟运算的定时步长回调为fixedUpdate()。在每次fixedUpdate回调中执行物理场景的simulate()函数之前，遍历物理场景下的所有动态刚体，如果刚体为Interpolate模式，要把对应刚体的位置和旋转记录下来。等执行update()回调的时候，Interpolate模式下，会根据之前记录的位置、旋转信息与当前刚体的信息进行差值计算。而Extrapolate模式下，在update()回调中会根据动态刚体的velocity和angularVelocity来预测计算出当前渲染时间点的刚体位置和旋转数据来。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/guide/Manual/Index.html">PhysX SDK</a><br><a href="https://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/apireference/files/index.html">PhysX API</a><br><a href="https://docs.unity3d.com/Manual/Physics3DReference.html">Unity Manual 3D Physics Reference</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> physics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>购买vps搭建ss服务教程</title>
      <link href="/2018/03/29/2018-03-29-vps-build-ss/"/>
      <url>/2018/03/29/2018-03-29-vps-build-ss/</url>
      
        <content type="html"><![CDATA[<h3 id="购买vps"><a href="#购买vps" class="headerlink" title="购买vps"></a>购买vps</h3><p>伴随着十*大的胜利召开，很多ss服务提供商都相继中招倒戈了，其中也包括我用了两年多的【一支红杏】。最后痛定思痛，决定还是自己折腾一下vps靠谱些，虽然价格上会稍微贵一点，但肯定会更稳定，而且用来搭建新的博客系统也是一个不错的选择。</p><p>在<a href="https://www.vpszh.com/">VPS中文网</a>上发现墙裂推荐了几款vps服务商，最后选择了  <strong>搬瓦工</strong> ，虽然性价比可能不是最高的，但是貌似针对中国线路做了很多优化，这样在速度上可能会更有优势吧。至于到底该选择哪家vps服务商，还是仁者见仁智者见智，主要还是得根据自己的切实需求来选择。</p><span id="more"></span><p>进入<a href="https://bwh1.net/"><strong>搬瓦工官网</strong></a>，可能大多数人会和我一样点击页面右上方的【Register】按钮来注册，注意的是里面的注册信息中，国家和邮箱一定一定不要乱填，其他的倒还都好。但是当你辛辛苦苦填完注册信息，点击【Submit】按钮的时候，却会提示你验证码输入失败，因为此时的你可能根本看不到验证码的存在，主要是因为搬瓦工用的是Google的验证码服务，所以你懂的。这就回归到了是先有鸡还是先有蛋的纠结上了，其实大可以直接选择你想要的vps主机配置，加到购物车然后进行__checkout__，进入结算页的时候，会再次弹出注册信息的填写，而且不再有验证码的限制了，这样就可以成功注册并购买vps服务。</p><p>话说回来，现在很多vps服务商都支持支付宝付款，个人觉得这点还是十分方便的，不用再去折腾master信用卡之类的支付方式。</p><h4 id="配置vps"><a href="#配置vps" class="headerlink" title="配置vps"></a>配置vps</h4><p>等注册购买成功后，点击右上方的【Client Area】，并选择【My Service】，会进入到如下界面：</p><p><img src="http://7xlmp2.com1.z0.glb.clouddn.com/bwh_my_service.png" alt="01"></p><p>点击右侧的【KiwiVM Control Panel】按钮，会进入到你的vps管理界面：</p><p><img src="http://7xlmp2.com1.z0.glb.clouddn.com/bwh_kiwivm_panel.png" alt="02"></p><p>下面有显示你的ip地址和端口号，如果需要重装系统的话，记得要先【stop】服务器，重装系统成功后，再重新【start】。我装的是Centos 6 x86_64 bbr，它会自动帮你开启bbr加速，就不用折腾其他的加速器了。</p><h4 id="搭建ss服务"><a href="#搭建ss服务" class="headerlink" title="搭建ss服务"></a>搭建ss服务</h4><p>以前在KiwiVM的管理面板左侧，就有一键安装ss服务的选项，但是现在没有了，需要自己来搭建。在网上搜了很多资料，其实很好搭建，就用pip来安装ss就可以了，省时省力不容易出错。</p><p>安装成功后在/etc目录新建shadowsocks.json文件，内容如下：</p><pre><code>&#123;&quot;server&quot;:&quot;你的ip&quot;,&quot;port_password&quot;:&#123;&quot;端口1&quot;:&quot;密码1&quot;,&quot;端口2&quot;:&quot;密码2&quot;,&quot;端口3&quot;:&quot;密码3&quot;&#125;,&quot;local_address&quot;:&quot;127.0.0.1&quot;,&quot;local_port&quot;:1080,&quot;timeout&quot;:300,&quot;method&quot;:&quot;rc4-md5&quot;&#125;</code></pre><p>编写保存好该json文件后，在命令行运行如下命令：</p><pre><code>ssserver -c /etc/shadowsocks.json -d start</code></pre><p>如果要关闭服务的话，则运行：</p><pre><code>ssserver -c /etc/shadowsocks.json -d stop</code></pre><p>服务启动成功后，只要在你的客户端连接vps的ip，并输入指定的端口和密码，以及加密方式就大功告成。</p><p>最后晒一张YouTube上一个1080的高清视频截图：</p><p><img src="http://7xlmp2.com1.z0.glb.clouddn.com/vps_youtube_1080.png" alt="03"></p>]]></content>
      
      
      <categories>
          
          <category> 网络相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度测试</title>
      <link href="/2017/04/13/2017-04-13-depth-test/"/>
      <url>/2017/04/13/2017-04-13-depth-test/</url>
      
        <content type="html"><![CDATA[<p><em>本文主要参考来自<a href="https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/01%20Depth%20testing/">《Learn OpenGL CN 深度测试》</a>这篇教程。</em></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在OpenGL中，__深度缓冲__的作用主要是为了防止3D场景中那些被遮挡的面渲染到前面（脱离了现实效果），它像颜色缓冲一样，存储着每个fragment的信息，通常和颜色缓冲区有相同的宽度和高度。深度缓冲区储存着的深度值可以表示为16、24或32位浮点数，多数情况下默认为24位。</p><p>下面说说__深度测试__，它发生在OpenGL管线中的fragment着色器运行之后的测试阶段，准确地说是在模板测试之后。深度测试默认是关闭着的，我们可以像这样来打开深度测试：</p><pre><code>glEnable(GL_DEPTH_TEST);</code></pre><p>开启深度测试就意味着OpenGL会去对深度缓冲中的深度值进行测试，而所谓的深度测试，实际上就是将fragment的实际z值与深度缓冲中存储着的对应z值通过__某种规则__进行比较。如果测试通过，会自动在深度缓冲区存储fragment的z值，测试失败则相应地丢弃该fragment。</p><p><strong>【特别注意】在每次渲染之前，应使用glClear(GL_DEPTH_BUFFER_BIT)来清除深度缓冲区，否则仍会保留上一次进行深度测试时所写的深度值。</strong></p><p>当然还存在这种情况，我们只想进行深度测试去丢弃那些未通过测试的fragment，但并不希望去更新深度缓冲区。此时，可以通过将其深度掩码设置为 <strong>GL_FALSE</strong> 来禁用深度缓冲区的写入操作。</p><pre><code>glDepthMask(GL_FALSE);</code></pre><span id="more"></span><h3 id="深度测试函数"><a href="#深度测试函数" class="headerlink" title="深度测试函数"></a>深度测试函数</h3><p>之前说深度测试会按照某种规则进行比较，实际上OpenGL为我们提供了接口来设置比较运算符（亦称depth function）。调用方式如下：</p><pre><code>glDepthFunc(GL_LESS);</code></pre><p>其中参数选项不仅仅包含GL_LESS，还有其他的选项配置，大致含义如下：</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>GL_ALWAYS</td><td>总是通过</td></tr><tr><td>GL_NEVER</td><td>永不通过</td></tr><tr><td>GL_LESS</td><td>fragment深度值小于缓冲区深度值时通过</td></tr><tr><td>GL_EQUAL</td><td>fragment深度值等于缓冲区深度值时通过</td></tr><tr><td>GL_LEQUAL</td><td>fragment深度值小于等于缓冲区深度值时通过</td></tr><tr><td>GL_GREATER</td><td>fragment深度值大于缓冲区深度值时通过</td></tr><tr><td>GL_NOTEQUAL</td><td>fragment深度值不等于缓冲区深度值时通过</td></tr><tr><td>GL_GEQUAL</td><td>fragment深度值大于等于缓冲区深度值时通过</td></tr></tbody></table><h3 id="深度值精度"><a href="#深度值精度" class="headerlink" title="深度值精度"></a>深度值精度</h3><p>存储在深度缓冲区中的深度值介于__0.0__和__1.0__之间，而与之比较的是视图空间中可见对象的z值，该z值介于投影平头截体的近面与远面之间。因此需要一些方法将视图空间z值转换到[0,1]的范围内。通常有__线性__与__非线性__两种方式，但实际上我们只会采用非线性的方式。</p><p>通常会让非线性深度方程和1/z成正比，这样做的目的是令那些可见对象的z值越近时精度越高，反之越远则精度越低。因此，在深度缓冲区中深度值为0.5并不意味着该对象的z值是在投影平头截体的中间位置。</p><h3 id="深度冲突"><a href="#深度冲突" class="headerlink" title="深度冲突"></a>深度冲突</h3><p>__深度冲突__是指两个图元紧密地相互平行，而深度缓冲区的精度不足以区分判断哪一个更靠前的时候，这两个形状会出现相互交替的怪异现象。深度冲突问题目前还无法完全避免，但可以利用如下方式尽量规避：</p><ol><li><p>使用glPolygonOffset函数，将其分开渲染，先渲染一个，再通过glPolygonOffset函数来设置偏移量，接着渲染第二个。这用解决方案在效率上会受到一些影响。</p></li><li><p>尽可能地把视椎体近面设置得远一些。由于越靠近视椎体近面的位置深度值的精度越高，所以我们将其移远后，可以有效提高视椎体内部的深度值精度。但需根据实际情况进行调整，因为如果近面移动的太远会导致近处的物体被剪裁掉。</p></li><li><p>提高深度缓冲区的精度，多数的深度缓冲区的精度都是24位，但是一些显卡支持32位的深度值，这会让深度缓冲区的精度大幅度提高，但也会牺牲一些性能。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua中实现面向对象</title>
      <link href="/2016/12/01/2016-12-01-lua-oo-implement/"/>
      <url>/2016/12/01/2016-12-01-lua-oo-implement/</url>
      
        <content type="html"><![CDATA[<h3 id="元表与元方法"><a href="#元表与元方法" class="headerlink" title="元表与元方法"></a>元表与元方法</h3><p>在Lua中并没有真正意义上的面向对象的概念，但通过其强大的数据结构table类型，我们可以模拟出面向对象的情境来。在这之前，需要先介绍一下Lua中的元表与元方法。</p><p>元表其实本质上仍是一个table，它为用户提供了自定义行为的途径。在元表中很很多以两个下划线为前缀的键名，我们称为“事件名”，而这个键对应的函数则叫做“元方法”。在元表的键中，除了用于运算操作符、连接操作符、取长操作符和比较操作符之外，还有三种比较常见的键:</p><pre><code>__index : 取下标操作，用于访问表中的域__newindex : 赋值操作，增改表中的域__call : 函数调用</code></pre><p>其中__index在面向对象的实现中十分重要，下面举个例子说明一下__index是如何工作的。当访问一个table中的某个属性时，Lua首先会查找该table中是否包含传入的键，如果找了对应的键，则将对应的值返回。但是如果没有找到键呢，那么Lua会接着去查找该表的元表（当然如果这个表没有元表的话，直接返回nil)，如果元表中包含__index键，则会执行其对应的元方法，若__index对应的是table，则会__递归性__地对这个table的元表中的__index进行查找，代码如下:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line">t.a <span class="comment">-- is nil</span></span><br><span class="line"><span class="keyword">local</span> tt = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(tt, &#123;</span><br><span class="line">    <span class="built_in">__index</span> = &#123; a = <span class="number">3</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line">tt.a <span class="comment">-- is 3</span></span><br></pre></td></tr></table></figure><p>上述代码中，tt表的定义并没有a属性，但是我们为它设置了一个元表，在元表中__index对应的table中定义了a的值等于3，因此当我们访问tt.a的时候就会取到3了。这个特性，也可以应用到面向对象的情境上。</p><span id="more"></span><h3 id="创建一个类"><a href="#创建一个类" class="headerlink" title="创建一个类"></a>创建一个类</h3><p>当创建一个类时，通常需要包含一个构造函数，并且能够通过new来创建一个该类的实例。实际上每次创建的类的实例对象，本质上仍然是一个table，但通过setmetatable来将类的table设置进去，这样实例就能访问到类的方法与属性了。具体代码如下:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 封装一个创建类的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">class</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> cls = &#123;&#125;</span><br><span class="line">    cls.<span class="built_in">__index</span> = cls</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 提供new接口来创建实例</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cls.new</span><span class="params">(...)</span></span></span><br><span class="line">        <span class="keyword">local</span> instance = <span class="built_in">setmetatable</span>(&#123;&#125;, cls)</span><br><span class="line">        <span class="comment">-- 执行构造函数</span></span><br><span class="line">        instance:ctor(...)</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用实例</span></span><br><span class="line"><span class="keyword">local</span> A = class()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A:ctor</span><span class="params">(name)</span></span></span><br><span class="line">    <span class="built_in">self</span>.name_ = name</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A:printName</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">self</span>.name_)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建类A的实例化对象a，并将传入的&quot;a&quot;通过ctor构造函数设置给self.name_</span></span><br><span class="line"><span class="keyword">local</span> a = A.new(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="comment">-- 执行打印a的name_属性</span></span><br><span class="line">a:printName()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="更复杂的类，继承"><a href="#更复杂的类，继承" class="headerlink" title="更复杂的类，继承"></a>更复杂的类，继承</h3><p>继承是面向对象编程中一个很重要的特性，而所谓的继承，就是子类能够对父类进行扩展，支持在子类中调用父类的方法。倘若子类没有某个属性或函数，可以直接使用父类的。在Lua中要实现继承的特性，本质上就是要去递归查找元表，不断地向上检索，直到找到对应的属性和方法，下面我们需要完善一下刚刚的class函数，令父类可以作为参数传递进去。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">class</span><span class="params">(super)</span></span></span><br><span class="line">    <span class="keyword">local</span> cls = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> super == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        cls = &#123; ctor = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">end</span> &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cls = <span class="built_in">setmetatable</span>(&#123;&#125;, super)</span><br><span class="line">        cls.super = super</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    cls.<span class="built_in">__index</span> = cls</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cls.new</span><span class="params">(...)</span></span></span><br><span class="line">        <span class="keyword">local</span> instance = <span class="built_in">setmetatable</span>(&#123;&#125;, cls)</span><br><span class="line">        instance:ctor(...)</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>下面让我们看看该如何在Lua中使用继承机制:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Base = class()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Base:ctor</span><span class="params">(name)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Base ctor&quot;</span>)</span><br><span class="line">    <span class="built_in">self</span>.name_ = name</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Base:printName</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Base printName &quot;</span>, <span class="built_in">self</span>.name_)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Sub = class(Base)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub:ctor</span><span class="params">(name)</span></span></span><br><span class="line">    <span class="built_in">self</span>.super.ctor(<span class="built_in">self</span>, name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sub ctor&quot;</span>)</span><br><span class="line">    <span class="built_in">self</span>.name_ = name</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub:printName</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">self</span>.super.printName(<span class="built_in">self</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sub printName &quot;</span>, <span class="built_in">self</span>.name_)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub:more</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sub more&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">sub</span> = Sub.new(<span class="string">&quot;sub&quot;</span>)</span><br><span class="line"><span class="built_in">sub</span>:printName()</span><br><span class="line"><span class="built_in">sub</span>:more()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 打印结果</span></span><br><span class="line">Base ctor</span><br><span class="line">Sub ctor</span><br><span class="line">Base printName  <span class="built_in">sub</span></span><br><span class="line">Sub printName  <span class="built_in">sub</span></span><br><span class="line">Sub more</span><br></pre></td></tr></table></figure><p>在上述代码中，子类Sub实现的函数中可以通过self.super来访问父类对应的函数或属性。假设如果子类Sub没有实现printName函数，在执行sub:printName()的时候则会去调用其父类Base的printName函数。</p><h3 id="继承来自C-绑定的userdata"><a href="#继承来自C-绑定的userdata" class="headerlink" title="继承来自C++绑定的userdata"></a>继承来自C++绑定的userdata</h3><p>在quick-cocos2d-x中，更加巧妙地封装了class函数，使得可以在Lua中去继承C++绑定的诸如CCNode等类的userdata。</p><p>使用class函数传入的super参数，如果类型是function或super.__ctype为1，表示该类根父类为C++绑定的userdata。superType是“table”，表示上级父类仍是一个Lua构造的类。首先会遍历super表，依次将对应键值赋给cls表。superType是“function”，表示直接继承着就是C++类，此时传入的参数super必须为function类型，该函数的返回值就是对应的userdata，同时会将super(此时是一个function)赋值给cls.__create，方便之后获取userdata。</p><p>在设置好__cname类名和__ctype标识后，我们再来看看new函数。利用cls.__create(…)来得到父类的userdata，遍历cls并将内容深度拷贝给instance，执行构造函数后并返回instance。以下是具体实现的代码:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> superType == <span class="string">&quot;function&quot;</span> <span class="keyword">or</span> (super <span class="keyword">and</span> super.__ctype == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- inherited from native C++ Object</span></span><br><span class="line">    cls = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> superType == <span class="string">&quot;table&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- copy fields from super</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(super) <span class="keyword">do</span> cls[k] = v <span class="keyword">end</span></span><br><span class="line">        cls.__create = super.__create</span><br><span class="line">        cls.super    = super</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cls.__create = super</span><br><span class="line">        cls.ctor = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    cls.__cname = classname</span><br><span class="line">    cls.__ctype = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cls.new</span><span class="params">(...)</span></span></span><br><span class="line">        <span class="keyword">local</span> instance = cls.__create(...)</span><br><span class="line">        <span class="comment">-- copy fields from class to native object</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(cls) <span class="keyword">do</span> instance[k] = v <span class="keyword">end</span></span><br><span class="line">        instance.class = cls</span><br><span class="line">        instance:ctor(...)</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上述代码剩余部分，是处理继承Lua构建类的流程，原理与之前的示例代码一致，不再重复贴出。</p>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Genymotion模拟器下载失败的解决方案</title>
      <link href="/2016/11/24/2016-11-24-genymotion-simulator-download/"/>
      <url>/2016/11/24/2016-11-24-genymotion-simulator-download/</url>
      
        <content type="html"><![CDATA[<h2 id="模拟器下载"><a href="#模拟器下载" class="headerlink" title="模拟器下载"></a>模拟器下载</h2><p><a href="www.genymotion.com">Genymotion</a>是一款出色、高效的Android模拟器，其免费版就足以满足一名Android开发者的日常需求，使用之后令人爱不释手。然而，当下载不同版本的Android模拟器的时候，总会发生 <strong>Connection timeout occurred</strong> 之类的错误，虽然可以断点续传，但还是造成了诸多不便。</p><p>解决办法就是拼接出所需下载的url地址，然后通过迅雷等下载工具进行下载，亲测速度虽然仍不是很快，但其稳定性是要好于使用浏览器下载的。在Mac操作系统中，Genymotion的模拟器文件会下载到 <strong>~/.Genymobile/Genymotion/ova</strong> 目录中，里面会有你要下载的模拟器文件的全称。然后根据如下规则拼接url：</p><pre><code>http://dl.genymotion.com/dists/版本/ova/文件名</code></pre><p>以下载7.0的模拟器为例，拼接后的url字就是：</p><pre><code>http://dl.genymotion.com/dists/7.0.0/ova/genymotion_vbox86p_7.0_160912_085006.ova</code></pre><p>在下载完成后，将ova文件替换至 <strong>~/.Genymobile/Genymotion/ova</strong> 即可。</p><span id="more"></span><h2 id="hosts修改"><a href="#hosts修改" class="headerlink" title="hosts修改"></a>hosts修改</h2><p>可能由于公司网络的原因，最近访问<a href="www.genymotion.com">Genymotion</a>或<a href="www.github.com">GitHub</a>时速度特别慢。于是google了一下，可能是CDN被墙了的缘故。浏览器打开 <a href="ip.chinaz.com">ip.chinaz.com</a> ，输入访问慢的dns域名，转换生成ip地址。进入终端输入 “sudo vim /etc/hosts” 打开hosts文件，编辑加入ip地址和dns域名即可。如下：</p><pre><code>104.16.215.67   www.genymotion.com151.101.36.133  assets-cdn.github.com192.30.253.113  github.com</code></pre><p>修改hosts文件后如果没有生效，建议重启浏览器或终端输入以下命令重启网络服务：</p><pre><code>sudo dscacheutil -flushcachesudo killall -HUP mDNSResponder</code></pre><p>如果有长期翻墙访问google的需求，建议使用<a href="laod.cn">老D博客</a>提供的hosts列表，会经常更新，如果访问不了再使用最新的hosts即可，网址 <a href="https://laod.cn/hosts/2016-google-hosts.html">https://laod.cn/hosts/2016-google-hosts.html</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 网络相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sol2使用教程</title>
      <link href="/2016/08/09/2016-08-09-sol2-tutorail/"/>
      <url>/2016/08/09/2016-08-09-sol2-tutorail/</url>
      
        <content type="html"><![CDATA[<h3 id="Sol2简介"><a href="#Sol2简介" class="headerlink" title="Sol2简介"></a>Sol2简介</h3><p>Sol是一个用于C++绑定Lua脚本的库，仅由头文件组成，方便集成，并提供了大量易用的API接口，可以便利地将Lua脚本与C++代码绑定起来，而不必去关心如何使用那些晦涩的Lua C API。正如其作者所言，Sol的目的就是提供极其简洁的API，并能高效到与C语言媲美，极大地来方便人们使用。</p><p>Sol支持Lua的绝大多数版本，包括 5.1、5.2、5.3和LuaJit等，但由于代码中用到了许多C++11/14特性，因此编译时需要编译器支持C++14标准。</p><p>具体使用以及介绍详情，请前往<a href="https://github.com/ThePhD/sol2">Github仓库</a>和<a href="http://sol2.readthedocs.io/en/latest/index.html">Sol2主页</a>。</p><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>从Sol的<a href="https://github.com/ThePhD/sol2">Github仓库</a>clone下代码后，我们发现其目录下很多test开头的cpp/hpp文件，这些文件里面有着大量的Sol的使用示例以及各种特性的展示，而在example目录下的cpp文件都仅仅是一些最基础的使用示例。为了方便测试和体验Sol，你也可以自己建立一些自己的test.cpp文件，首先你要在源文件中include引用sol.hpp头文件，这样才能使用Sol提供的接口。而在使用gcc编译的时候，需要指定关联头文件的路径，可以使用如下命令：</p><pre><code>g++ test.cpp -Isolpath/single/sol -llua -std=c++14</code></pre><p>其中solpath是你Sol2的具体路径，在Sol2的项目目录下，有一个single/sol/sol.hpp头文件，这个头文件集成了所有的相关代码到一起，所以编译时 -I 后仅指定这一个路径就可以了，同时要保证你的gcc编译器支持C++14标准。</p><span id="more"></span><h4 id="绑定第一个类"><a href="#绑定第一个类" class="headerlink" title="绑定第一个类"></a>绑定第一个类</h4><pre><code>#include &quot;stdio.h&quot;#include &quot;sol.hpp&quot;class A&#123;public:    A () = default;    A (int a) &#123; mA = a; &#125;;    virtual ~A() = default;    void foo()    &#123;        printf(&quot;foo excute!\n&quot;);    &#125;private:    int mA;&#125;int main(void)&#123;    sol::state lua;    // 打开lua中的相关库，如table、string等    lua.open_libraries();    lua.new_usertype&lt;A&gt;    (        &quot;A&quot;, // Lua中识别的类名        sol::constructors&lt;sol::types&lt;int&gt;&gt;(),        &quot;foo&quot;, &amp;A::foo // 绑定成员函数foo    )    // 执行一段Lua程序    lua.script(&quot; local a = A.new(); a:foo(); &quot;)&#125;</code></pre><p>上述程序中，将一个简单的类A绑定到了Lua代码中，在Lua代码中可以创建一个a对象并调用其成员函数foo()。其中，A类除了默认构造函数外，还有一个带参数的构造函数，需要使用sol::constructors进行封装，并通过sol::types&lt;&gt;模板来指定其参数列表。</p><h4 id="设置全局函数"><a href="#设置全局函数" class="headerlink" title="设置全局函数"></a>设置全局函数</h4><p>我们可以将一个C++的函数设置到Lua中作为全局函数调用，代码如下:</p><pre><code>sol::state lua;lua.set_function(&quot;func&quot;, func); // func变量为C++函数地址</code></pre><h4 id="重载函数绑定"><a href="#重载函数绑定" class="headerlink" title="重载函数绑定"></a>重载函数绑定</h4><p>如果一个类中的某个成员函数被重载了，即函数名及返回值相同，参数列表不同。我们可以这样绑定:</p><pre><code>sol::state lua;lua.new_usertype&lt;A&gt;(    &quot;A&quot;, // sol会帮你构造一个默认构造函数    &quot;foo&quot;, sol::overload(sol::resolve&lt;void(int)&gt;(&amp;A::foo),        sol::overload(sol::resolve&lt;void(int, int)&gt;(&amp;A::foo))))</code></pre><p>假设A类包含两个名字都叫做foo的成员函数，都没有返回值(void)，一个是需要一个int作为参数，另一个是需要两个int作为参数，当Lua代码中调用foo函数的时候，Sol会根据你传递的参数来判断调用对应哪个绑定的C++函数。</p><h4 id="将枚举映射到Lua的全局table中"><a href="#将枚举映射到Lua的全局table中" class="headerlink" title="将枚举映射到Lua的全局table中"></a>将枚举映射到Lua的全局table中</h4><p>有时候在C++中会定义许多枚举，为了方便Lua代码中可以方便地使用对应的枚举类型，我们可以将其绑定到一个Lua全局table中。</p><pre><code>enum Color&#123;    RED,    GREEN,    BLUE&#125;;sol::state lua;lua[&quot;Color&quot;] = lua.create_table_with(&quot;RED&quot;, RED, &quot;GREEN&quot;, GREEN, &quot;BLUE&quot;, BLUE);lua.script(&quot;Color.RED&quot;)</code></pre><p>上段代码中，我们实际上构建了一个全局table，名字叫做Color，并将table的key对应的value设置成枚举Color中的对应项，这样就实现了在Lua使用某个枚举里的内容。</p><h3 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h3><h4 id="将Lua的table传到C-中"><a href="#将Lua的table传到C-中" class="headerlink" title="将Lua的table传到C++中"></a>将Lua的table传到C++中</h4><p>很多时候，我们需要将一个table传到C++层来使用，Sol为我们封装了sol::table类型来表示Lua中的table，假设我们定义了一个C++函数，其参数就是sol::table。</p><pre><code>void foo(sol::table t)&#123;    // t 表示一个从Lua层传来的table&#125;sol::state lua;lua.set_function(&quot;foo&quot;, foo);lua.script(&quot;local t = &#123; 1, 2, 3, 4 &#125;; foo(t); &quot;)</code></pre><p>通过上边Lua代码的调用，使得一个内容是“1, 2, 3, 4”的table传给了C++层。</p><h4 id="遍历Lua传来的table"><a href="#遍历Lua传来的table" class="headerlink" title="遍历Lua传来的table"></a>遍历Lua传来的table</h4><p>由于Lua中只有table这一种数据结构，它既可以表示数组也可以表示HashMap的结构，因此遍历获取sol::table中的内容显得更加复杂。Sol重载了[]让我们可以很方便地去获取table中的值，可以传递索引或key值。</p><pre><code>void foo(sol::table t)&#123;    // lua table &#123; 1, 2, 3, 4 &#125;    sol::object obj = t[1];    int first = obj.as&lt;int&gt;();  // first is 1    // lua table &#123; a = &quot;a&quot;, b = 2 &#125;    sol::object a = t[&quot;a&quot;];    sol::object b = t[&quot;b&quot;];    sol::type atype = a.get_type(); // atype 等于 sol::type::string    sol::type btype = b.get_type(); // btype 等于 sol::type::number    std::string astr = a.as&lt;std::string&gt;(); // a    int bnum = b.as&lt;int&gt;();  // 2&#125;</code></pre><p>通过[]得到的table中的值并不能直接当成number或是string来使用，它实际上是sol::proxy代理类型，我们可以将其隐式转换成sol::object类型，并通过 <strong>as&lt;&gt;()</strong> 来获取其在Lua中代表的值对应的C++类型。</p><p>如果我们并不清楚这个Lua层传入的table是怎样的结构，可以采取遍历并判断对应key、value的类型，从而得到我们实际想要的值，代码如下：</p><pre><code>void foo(sol::table t)&#123;    for (auto&amp; kv : t)    &#123;        sol::object key = kv.first;        sol::object val = kv.second;        printf(&quot;key type : %d, val type : %d\n&quot;, key.get_type(), val.get_type());        switch (key.get_type())        &#123;            case sol::type::number:                // 这是一个数组                break;            case sol::type::string:                // 键值对table                break;        &#125;        switch (val.get_type())        &#123;            case sol::type::number:                break;            case sol::type::string:                break;            case sol::type::table:                break;        &#125;    &#125;&#125;</code></pre><h4 id="让代码更加健壮"><a href="#让代码更加健壮" class="headerlink" title="让代码更加健壮"></a>让代码更加健壮</h4><p>由于在Lua中类型的概念很弱，函数定义的参数并不会指定具体类型，这导致当我们想调用某个C++绑定过来的接口传递table的时候，很有可能有意或无意传递了一个nil过去。如果该函数在C++中指定的类型是sol::table，而在Lua传递一个nil值会发生很多不可控的错误，因此需要我们针对这种情况特殊处理以保证代码更加健壮。</p><p>无论是sol::object还是sol::table、sol::function等类型，都继承于sol::reference类。因此，可以通过定义在sol::reference中的 <strong>valid()</strong> 函数即可判断当前对象是否可用。sol::table类型也可以通过 <strong>empty()</strong> 来判断当前table是否包含内容。</p><pre><code>void foo(sol::table t)&#123;    if (! t.valid() || t.empty())        return;    // 执行到这表明t并不为nil或是空表，可以继续代码逻辑&#125;</code></pre><h4 id="隐式传递Lua状态机"><a href="#隐式传递Lua状态机" class="headerlink" title="隐式传递Lua状态机"></a>隐式传递Lua状态机</h4><p>虽然Sol帮我们封装了很多简单易用的接口，但实际开发过程中难免还是需要自己去和Lua状态机打交道。在之前代码经常出现的sol::state中，我们可以通过 <strong>lua_state()</strong> 接口来获取lua_State指针。</p><p>同时，Sol封装了一个sol::this_state结构体，可以方便地将其隐式地转成lua_State指针。在绑定到Lua中的C++函数里，可以在参数列表的任意位置添加sol::this_state声明，而在Lua代码中调用该函数时则可以忽略该参数，Sol会自动帮你将Lua代码执行时的状态机作为sol::this_state来进行传递。</p><pre><code>void foo(sol::table t, sol::this_state l)&#123;    // 向Lua栈中push一个字符串    lua_pushstring(l, &quot;hello&quot;);    // 构建一个sol::object对象    sol::object obj = sol::make_object(l, t);&#125;int main(void)&#123;    sol::state lua;    lua.set_function(&quot;foo&quot;, foo);    // 执行Lua代码时，调用foo函数仅传递了一个table作为参数    lua.script(&quot;local t = &#123; a = 1, b = 2 &#125;; foo(t);&quot;);&#125;</code></pre><h4 id="C-与Lua的返回值"><a href="#C-与Lua的返回值" class="headerlink" title="C++与Lua的返回值"></a>C++与Lua的返回值</h4><h5 id="接收来自Lua的多个返回值"><a href="#接收来自Lua的多个返回值" class="headerlink" title="接收来自Lua的多个返回值"></a>接收来自Lua的多个返回值</h5><pre><code>int main () &#123;    sol::state lua;    lua.script(&quot;function f (a, b, c) return a, b, c end&quot;);    std::tuple&lt;int, int, int&gt; result;    result = lua[&quot;f&quot;](1, 2, 3);    // result == &#123; 1, 2, 3 &#125;    int a, int b;    std::string c;    sol::tie( a, b, c ) = lua[&quot;f&quot;](1, 2, &quot;bark&quot;);    // a == 1    // b == 2    // c == &quot;bark&quot;&#125;</code></pre><h5 id="返回多种类型给Lua"><a href="#返回多种类型给Lua" class="headerlink" title="返回多种类型给Lua"></a>返回多种类型给Lua</h5><p>在C++代码中，无法做到像Lua那样可以灵活地返回各种类型的值，但是我们可以利用sol::object来封装成不同的“Lua类型”返回给Lua层。</p><pre><code>sol::object fancy_func (sol::object a, sol::object b, sol::this_state s) &#123;    sol::state_view lua = s;    if (a.is&lt;int&gt;() &amp;&amp; b.is&lt;int&gt;()) &#123;            return sol::make_object(lua, a.as&lt;int&gt;() + b.as&lt;int&gt;());    &#125;    else if (a.is&lt;bool&gt;()) &#123;            bool do_triple = a.as&lt;bool&gt;();            return sol::make_object(lua, b.as&lt;double&gt;() * ( do_triple ? 3 : 1 ) );    &#125;    return sol::make_object(lua, sol::nil);&#125;sol::state lua;lua[&quot;f&quot;] = fancy_func;int result = lua[&quot;f&quot;](1, 2);// result == 3double result2 = lua[&quot;f&quot;](false, 2.5);// result2 == 2.5// call in Lua, get resultlua.script(&quot;result3 = f(true, 5.5)&quot;);double result3 = lua[&quot;result3&quot;];// result3 == 16.5</code></pre>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lua binding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua的gc机制</title>
      <link href="/2016/03/02/2016-03-02-lua-gc/"/>
      <url>/2016/03/02/2016-03-02-lua-gc/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><p>在Lua中会自动帮你管理内存，通过gc(垃圾收集器)来收集所有不可能再访问到的死对象，因此开发者们不必去操心该如何释放对象所占用的内存。而Lua中目前适用于自动垃圾回收的类型包括: <em>string</em> 、 <em>table</em> 、 <em>userdata</em> 、 <em>function</em> 、 <em>thread</em> 等。</p><p>Lua所采用的gc算法叫做 <strong>标记&amp;回收算法</strong> 。其原理是在每一次gc时会首先扫描并标记系统中的所有对象，被扫描到并标记的对象认为可达的，在gc中并不会回收，反之则会在gc中被回收释放掉。</p><p>早期的Lua采用的是双色标记回收算法，即系统中的对象只支持两种状态：<em>black</em> 和 <em>white</em> 。每个新创建的对象的颜色为白色，若其他地方存在该对象的引用，则将其标记为黑色，在进入gc的回收阶段时，会将白色的对象回收释放掉。这个算法存在一个比较大的缺陷，整个gc过程必须保证是原子性的不能被打断。假设在遍历对象链表标记对象颜色的时候中断，而此时新增了一个对象，这个对象的颜色属性很难确定。如果该新增对象标记为白色，而gc到了回收阶段，这个对象就会在没有遍历其关联对象的情况下被回收；如果标记为黑色，那么进入回收阶段后，该对象在没有被扫描的情况下就认为是不必回收的。因此，标记阶段和回收阶段必须合在一起完成，不能被打断。如此一来，gc的代价也会显得异常昂贵。</p><p>在之后的Lua 5.1版本中改进了这个算法，增加了新的颜色状态 ： <em>gray</em> 。</p><p>相比之前，每个对象多了一种颜色状态，从而保证了gc过程可以是增量的，能够被中断后继续进行。这三种颜色分类如下：</p><ul><li><strong>white</strong> : 当前对象还没有被gc访问标记过，新增对象的初始状态，如果一个对象在标记过程后仍为白色，则表示该对象没有被系统中的其他对象所引用，可以回收；</li><li><strong>gray</strong>  : 表示该对象已经被gc访问过，但是该对象引用的其他对象还没有被访问到；</li><li><strong>black</strong> : 表示该对象已经被gc访问过，并且该对象引用的其他对象也已经被访问过。</li></ul><p>如此一来，只要存放灰色对象的链表不为空，标记过程就会继续下去，直到gray链表清空，表示所有对象都被扫描过了。但即使新增了灰色中间状态，仍然存在一个问题。假如在标记过程结束后gc中断，新建了一个对象，此时它的状态应该是白色，但紧接着的回收阶段，会将这个没有被扫描标记的对象认为是没有被引用的对象而回收释放掉。为解决这个问题，Lua又细化出了“双白色”的概念，即将 <em>white</em> 细分为 currentwhite 和 otherwhite 。每次gc会使用其中的一种 <em>white</em> ，而下次gc则使用另外一个，交替递推。这样在回收阶段，会判断相应对象的 <em>white</em> 是否和当前gc的 <em>white</em> 是否相同，如果相同则会让这个对象等到下次gc中扫描回收，不同则将其回收。</p><span id="more"></span><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>接下来结合Lua 5.3.2的源代码，进行gc流程的相关分析，其中gc的入口函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">luaC_fullgc</span> <span class="params">(lua_State *L, <span class="keyword">int</span> isemergency)</span> </span>&#123;</span><br><span class="line">  global_State *g = <span class="built_in">G</span>(L);</span><br><span class="line">  <span class="built_in">lua_assert</span>(g-&gt;gckind == KGC_NORMAL);</span><br><span class="line">  <span class="keyword">if</span> (isemergency) g-&gt;gckind = KGC_EMERGENCY;  <span class="comment">/* set flag */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">keepinvariant</span>(g)) &#123;  <span class="comment">/* black objects? */</span></span><br><span class="line">    <span class="built_in">entersweep</span>(L); <span class="comment">/* sweep everything to turn them back to white */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* finish any pending sweep phase to start a new cycle */</span></span><br><span class="line">  <span class="built_in">luaC_runtilstate</span>(L, <span class="built_in">bitmask</span>(GCSpause));</span><br><span class="line">  <span class="built_in">luaC_runtilstate</span>(L, ~<span class="built_in">bitmask</span>(GCSpause));  <span class="comment">/* start new collection */</span></span><br><span class="line">  <span class="built_in">luaC_runtilstate</span>(L, <span class="built_in">bitmask</span>(GCScallfin));  <span class="comment">/* run up to finalizers */</span></span><br><span class="line">  <span class="comment">/* estimate must be correct after a full GC cycle */</span></span><br><span class="line">  <span class="built_in">lua_assert</span>(g-&gt;GCestimate == <span class="built_in">gettotalbytes</span>(g));</span><br><span class="line">  <span class="built_in">luaC_runtilstate</span>(L, <span class="built_in">bitmask</span>(GCSpause));  <span class="comment">/* finish collection */</span></span><br><span class="line">  g-&gt;gckind = KGC_NORMAL;</span><br><span class="line">  <span class="built_in">setpause</span>(g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合代码和函数注释，我们不难发现，该函数执行了一套完整的gc周期。其中gc包括两种种类，KGC_NORMAL和KGC_ENMERGENCY。在根据参数 <em>isenergency</em> 设置好gc状态之后，会调用 <em>keepinvariant</em> 来判断当前的gc阶段状态，如果仍处于标记阶段，则调用 <em>entersweep(L)</em> 进入扫描初级阶段(GCSswpallgc)，调用 <em>sweeptolive(L, &amp;g-&gt;allgc, &amp;n)</em> 并将其返回值赋给全局状态机的 <em>sweepgc</em> 字段，表示当前扫描链表的位置。</p><p>接下来会连续调用四遍 <em>luaC_runtilstate()</em> 函数，该函数会根据你传入的状态标识位与当前全局状态机的gcstate进行按位与运算，不同则会调用 <em>singlestep(L)</em> 函数。该函数里是一个大的switch语句，根据gcstate进行划分，我们可以很清晰地看到gc过程的8个阶段。下面我们来分别介绍一下这些阶段状态的含义：</p><ul><li><strong>GCSpause</strong> : gc前的初始化状态，global_State中的相关链表置成NULL，标记主线程的全局表、注册表等</li><li><strong>GCSpropagate</strong> : 标记阶段，将gray链表的元素标记为黑色并移除，如果gray链表为空则置换状态为GCSatomic</li><li><strong>GCSatomic</strong> : 标记阶段的原子操作，不可中断</li><li><strong>GCSswpallgc</strong> : 扫描回收常规对象</li><li><strong>GCSswpfinobj</strong> : 扫描回收被终止器标记的对象</li><li><strong>GCSswptobefnz</strong> : 扫描回收带有gc回调的udata对象</li><li><strong>GCSswpend</strong> : 扫描回收阶段结束阶段，扫描主线程、缩减字符串池大小</li><li><strong>GCScallfin</strong> : tobefnz不为NULL并且非紧急模式，则调用gc回调（通过GCTM），否则将状态置成GCSpause</li></ul><h3 id="释放流程"><a href="#释放流程" class="headerlink" title="释放流程"></a>释放流程</h3><p>在 <em>sweeplist</em> 函数中会判断如果不是当前gc过程中对应white的对象，会调用 <em>freeobj()</em> 函数，并将该对象节点移除链表。具体的freeobj()代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">freeobj</span> <span class="params">(lua_State *L, GCObject *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (o-&gt;tt) &#123;</span><br><span class="line">      <span class="keyword">case</span> LUA_TPROTO: luaF_freeproto(L, gco2p(o)); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> LUA_TLCL: &#123;</span><br><span class="line">        freeLclosure(L, gco2lcl(o));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> LUA_TCCL: &#123;</span><br><span class="line">        luaM_freemem(L, o, sizeCclosure(gco2ccl(o)-&gt;nupvalues));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> LUA_TTABLE: luaH_free(L, gco2t(o)); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> LUA_TTHREAD: luaE_freethread(L, gco2th(o)); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> LUA_TUSERDATA: luaM_freemem(L, o, sizeudata(gco2u(o))); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> LUA_TSHRSTR:</span><br><span class="line">        luaS_remove(L, gco2ts(o));  <span class="comment">/* remove it from hash table */</span></span><br><span class="line">        luaM_freemem(L, o, sizelstring(gco2ts(o)-&gt;shrlen));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> LUA_TLNGSTR: &#123;</span><br><span class="line">        luaM_freemem(L, o, sizelstring(gco2ts(o)-&gt;u.lnglen));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>: lua_assert(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知，该函数会根据待释放回收的对象类型进行对应操作，具体分析将在之后的针对Lua类型说明以及内存管理相关的博客中具体展开。</p>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Mac系统上搭建OpenGL开发环境</title>
      <link href="/2016/01/08/2016-01-08-mac-config-opengl/"/>
      <url>/2016/01/08/2016-01-08-mac-config-opengl/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是OpenGL"><a href="#什么是OpenGL" class="headerlink" title="什么是OpenGL"></a>什么是OpenGL</h3><p>( <em>以下来自<a href="https://zh.wikipedia.org/wiki/OpenGL">维基百科</a></em> )</p><p>OpenGL英文全称 <em>Open Graphics Library</em> ，是一个开放图形库，定义了一个跨编程语言、跨平台的API规范，它用于生成二维、三维图像。这个接口由近三百五十个不同的函数调用组成，用来从简单的图形比特绘制复杂的三维景象。而另一种程序界面系统是仅用于Microsoft Windows上的Direct3D。OpenGL常用于CAD、虚拟实境、科学可视化程序和电子游戏开发。</p><p>OpenGL的高效实现（利用了图形加速硬件）存在于Windows，很多UNIX平台和Mac OS。这些实现一般由显示设备厂商提供，而且非常依赖于该厂商提供的硬件。开放源代码库Mesa是一个纯基于软件的图形API，它的代码兼容于OpenGL。但是，由于许可证的原因，它只声称是一个“非常相似”的API。</p><p>OpenGL规范由1992年成立的OpenGL架构评审委员会（ARB）维护。ARB由一些对创建一个统一的、普遍可用的API特别感兴趣的公司组成。根据OpenGL官方网站，2002年6月的ARB投票成员包括3Dlabs、Apple Computer、ATI Technologies、Dell Computer、Evans &amp; Sutherland、Hewlett-Packard、IBM、Intel、Matrox、NVIDIA、SGI和Sun Microsystems，Microsoft曾是创立成员之一，但已于2003年3月退出。</p><h3 id="一些常见的库"><a href="#一些常见的库" class="headerlink" title="一些常见的库"></a>一些常见的库</h3><h4 id="GLEW"><a href="#GLEW" class="headerlink" title="GLEW"></a>GLEW</h4><p><a href="https://github.com/nigels-com/glew">GLEW</a>是一个OpenGL扩展库，在现代OpenGL中，API函数是在运行时确定的，而不是编译期。GLEW可以帮助我们在运行时加载OpenGL API。</p><p>它的编译十分简单，通过Github下载源代码后，在终端进入glew目录，并在终端下依次执行如下命令即可。</p><pre><code>make extensionssudo make install</code></pre><p>这样在我们的系统目录/usr/local/include和/usr/local/lib下会生成GLEW的相关头文件与静态库文件，之后创建项目时我们会用到。</p><span id="more"></span><h4 id="GLFW"><a href="#GLFW" class="headerlink" title="GLFW"></a>GLFW</h4><p><a href="https://github.com/glfw/glfw">GLFW</a>是一款开源、跨平台的图形窗口管理库，不仅可以用来管理窗口，还支持读取输入，处理事件等。</p><p>在Mac系统上我们需要使用<a href="https://cmake.org/">CMake</a>来编译GLFW。首先在Github上clone下GLFW的源代码，然后在glfw目录下新建立一个build-glfw目录(其实这个目录建立在什么地方都可以)，然后打开CMake图形软件的界面入下图</p><p><img src="http://7xlmp2.com1.z0.glb.clouddn.com/2016-01-08-mac-config-opengl-01.png" alt="01"></p><p>点击 <em>Configure</em> 按钮，选择 <strong>unix makefile</strong> 选项，如果列表中有红色提示的话，再点击一下 <em>Configure</em> 按钮，接着点击 <em>Generate</em> 按钮。没有出错的话，在终端中cd进入build-glfw目录，执行 <strong>sudo make install</strong> 。同样地，会在系统目录/usr/local/include和/usr/local/lib下会生成GLFW的相关头文件与静态库文件。</p><h4 id="GLM"><a href="#GLM" class="headerlink" title="GLM"></a>GLM</h4><p><a href="https://github.com/g-truc/glm">GLM</a>是一款仿照GLSL语言开发的C++图形软件数学库，它只包含C++的hpp头文件。与GLFW一样，它也可以通过Cmake来在Mac系统中编译，操作步骤类似，唯一不同的是，由于GLM仅仅包含头文件，所以编译不会生成静态库文件，只会生成/usr/local/include/glm目录。</p><h4 id="SOIL"><a href="#SOIL" class="headerlink" title="SOIL"></a>SOIL</h4><p><a href="http://www.lonesock.net/soil.html">SOIL</a>是一个跨平台的图片加载库，它支持加载多种图片格式，生成OpenGL的纹理。下载好该库的代码后，需要自己再编译一下。进入projects/makefile目录，新建立 <em>obj</em> 目录，并修改makefile文件，在CXXFLAGS增加”-m64”选项，即 <strong>CXXFLAGS = -O2 -s -Wall -m64</strong> 。然后在makefile目录执行 <em>make</em> 和 <em>sudo make install</em> ，将lib目录新生成的libSOIL.a库文件增加到xcode的链接库中。</p><h3 id="使用Xcode建立项目"><a href="#使用Xcode建立项目" class="headerlink" title="使用Xcode建立项目"></a>使用Xcode建立项目</h3><p>打开Xcode，建立一个 <strong>Command Line Tool</strong> 项目。在Build Settings中找到Search Paths选项，在Header Search Paths中加入 <strong>/usr/local/include/GLFW</strong> 、 <strong>/usr/local/include/glm</strong> 、 <strong>/usr/local/include</strong> 和 <strong>/usr/local/include/GL</strong> ，在Library Search Paths中添加 <strong>/usr/local/lib</strong> ，记住最右面要选择成recursive的，具体效果如下图显示。</p><p><img src="http://7xlmp2.com1.z0.glb.clouddn.com/2016-01-08-mac-config-opengl-02.png" alt="02"></p><p>接着在Build Phases中的Link Binary With Libraries选项中添加我们要链接的库，如下图所示。</p><p><img src="http://7xlmp2.com1.z0.glb.clouddn.com/2016-01-08-mac-config-opengl-03.png" alt="03"></p><p>具体包括的系统链接有</p><pre><code>CoreFoundation.frameworkCarbon.frameworkGLUT.frameworkOpenGL.frameworkCocoa.frameworkIOKit.frameworkCoreVideo.framework</code></pre><p>而libGLEW.a和libglfw3.a是我们之前编译好并安装到/usr/local/lib下的静态库。由于系统权限原因，我们可以进入终端输入命令 <strong>open /usr/local/lib</strong> 来通过finder打开该目录，并将libGLEW.a和libglfw3.a拖拽到Xcode的Link Binary With Libraries中即可。</p><p>接下来，你便可以在main.cpp中include相应的头文件了，晒一段简单的创建窗口的代码。</p><pre><code>#include &lt;glew.h&gt;#include &lt;glfw3.h&gt;int main(int argc, const char * argv[]) &#123;    GLFWwindow* window;    if (!glfwInit())        return -1;    window = glfwCreateWindow(640, 480, &quot;Hello World&quot;, NULL, NULL);    if (!window)    &#123;        glfwTerminate();        return -1;    &#125;    glfwMakeContextCurrent(window);    while (!glfwWindowShouldClose(window))    &#123;        glfwSwapBuffers(window);        glfwPollEvents();    &#125;    glfwTerminate();    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android插件机制研究分析</title>
      <link href="/2015/11/28/2015-11-28-android-plugin/"/>
      <url>/2015/11/28/2015-11-28-android-plugin/</url>
      
        <content type="html"><![CDATA[<h3 id="初识插件化"><a href="#初识插件化" class="headerlink" title="初识插件化"></a>初识插件化</h3><p>早在Android 2.3的年代，依旧存在着著名的 <strong>65535</strong> 问题，即应用项目内的最大方法数不能超过65535个，否则无法编译通过。随着应用业务逻辑的不断发展，无论如何优化代码，也很快会遇到这个瓶颈。多数的解决方案，是通过拆分并装载多个dex字节码文件来规避这个问题。但对于结构复杂、业务逻辑繁重的应用来说，仅仅拆分dex文件是远远不够的，因此，插件化的这个概念也随之应运而生。</p><p>所谓 <strong>插件化</strong> ，我们可以理解为将一个单独的apk文件，通过某种机制，使其可以在未安装的状态下直接运行。这样一来，我们便可以将主应用的多个业务模块拆分出来，单独编译成不同的apk文件，不仅可以减轻主应用的体积，还能使业务逻辑模块化，降低模块间的耦合。</p><p>简要概括下来，插件化主要包括以下三个优点：</p><ul><li><p>动态更新<br>  当某个业务模块需要改进更新的时候，不用再升级安装庞大的宿主应用，仅仅自动下载对应的轻量插件便可以，并且无需用户去安装。这对于产品的迭代优化，紧急Bug的修复都有着很大的帮助。</p></li><li><p>可定制化<br>  插件化在降低模块耦合的同时，也为应用的定制给予了极大的便利。针对不同的发布渠道或是运营需要，宿主应用能够在不修改代码的情况下从容地进行定制，大大降低了发布成本。</p></li><li><p>并行协作开发<br>  对于大型应用，独立的插件可以在不同的团队之间并行进行开发，缩短项目进程，提高开发效率。</p></li></ul><span id="more"></span><h3 id="插件机制的具体实现"><a href="#插件机制的具体实现" class="headerlink" title="插件机制的具体实现"></a>插件机制的具体实现</h3><p>目前在Android平台实现插件机制的方法主要包括两种： <em>宿主注册代理组件，反射绑定维护插件对应组件</em> 和 <em>利用动态代理技术hook系统以管理运行插件</em> 。目前使用这两种技术并在github上拥有2k+ star的开源项目有 <a href="https://github.com/singwhatiwanna/dynamic-load-apk">dynamic-load-apk</a> 和 <a href="https://github.com/Qihoo360/DroidPlugin">DroidPlugin</a>，下面来分别介绍一下。</p><h4 id="dynamic-load-apk"><a href="#dynamic-load-apk" class="headerlink" title="dynamic-load-apk"></a><a href="https://github.com/singwhatiwanna/dynamic-load-apk">dynamic-load-apk</a></h4><p>这个项目是由百度资深Android开发工程师<a href="http://my.csdn.net/singwhatiwanna">任玉刚</a>发起的，具体结构层次图(来自其说明文档)如下：</p><p><img src="http://7xlmp2.com1.z0.glb.clouddn.com/dl-frame.png" alt="dynamic-load-apk结构层次图"></p><p>其实现原理就是先在宿主程序中注册好用于代理的Activity和Service组件，并在其onCreate生命周期函数中对需启动的插件利用反射进行相关绑定以及初始化的操作。启动插件的Activity或是Service组件，实际上就是启动宿主本地的代理组件，并在执行代理组件生命周期函数的同时，绑定执行对应插件组件的声明周期函数。</p><p>具体相关源码的分析可以参考这篇<a href="http://a.codekk.com/detail/Android/FFish/DynamicLoadApk%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">文章</a>。</p><p>在使用dynamic-load-apk框架开发插件时，存在着一些限制，如插件内的Activity或Service需继承框架库封装的DLBasePluginActivity或DLBasePluginService（插件项目要外部引入dl-lib.jar），而不能直接继承Activity和Service，因为需要插件库去帮你管理插件组件的声明周期。并且，插件apk也不能独立运行与Android设备上，对于开发调试与插件移植还是存在着一定的困难。但是其结构清晰简单，并且有着丰富的说明文档，足够满足一些简单的插件实现，帮助实现插件化的管理工作。</p><h4 id="DroidPlugin"><a href="#DroidPlugin" class="headerlink" title="DroidPlugin"></a><a href="https://github.com/Qihoo360/DroidPlugin">DroidPlugin</a></h4><p>这是奇虎360开源的一款插件机制框架，并成功运用于360手机助手软件上帮助其实现一些插件化的功能。</p><p>DroidPlugin实现原理不同于之前的dynamic-load-apk，它利用Java的动态代理技术将Android Framework层hook住并替换成自己实现的各种Manager，这样就模拟出来了一个伪Android系统，可以达到欺上瞒下的功效——让插件apk文件认为自己被安装过了，让系统认为插件apk确实被安装过了。</p><p>下面是DroidPlugin的实现原理图：</p><p><img src="http://7xlmp2.com1.z0.glb.clouddn.com/DroidPlugin-frame.png" alt="DroidPlugin原理图"></p><p>虽然DroidPlugin框架hook住了整个framework并使其插件可以“浑水摸鱼”来运行于系统之上，却仍然存在着一些限制缺陷。</p><ul><li><p>无法在插件中发送具有自定义资源的Notification；</p></li><li><p>无法在插件中注册一些具有特殊Intent Filter的Service、Activity、BroadcastReceiver、ContentProvider等组件以供Android系统、已经安装的其他APP调用；</p></li><li><p>缺乏对Native层的Hook，使其诸如基于cocos2d-x或是u3d开发手机游戏不能很好地作为插件运行。</p></li></ul><p>但是其优点也显而易见，插件apk不依赖任何lib库，并能够直接安装运行与Android系统之上，几乎做到了让apk文件在不安装的情况运行起来。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的2014-2015</title>
      <link href="/2015/11/03/2015-01-03-year-summary/"/>
      <url>/2015/11/03/2015-01-03-year-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="回顾2014"><a href="#回顾2014" class="headerlink" title="回顾2014"></a>回顾2014</h2><h3 id="1-搭建自己的github博客，学习通过使用md来写博客"><a href="#1-搭建自己的github博客，学习通过使用md来写博客" class="headerlink" title="1. 搭建自己的github博客，学习通过使用md来写博客"></a>1. 搭建自己的github博客，学习通过使用md来写博客</h3><h3 id="2-学习使用github来关注一些优秀的开源项目"><a href="#2-学习使用github来关注一些优秀的开源项目" class="headerlink" title="2. 学习使用github来关注一些优秀的开源项目"></a>2. 学习使用github来关注一些优秀的开源项目</h3><h3 id="3-自学了python脚本语言，用于日常工作开发中的一些工具的编写"><a href="#3-自学了python脚本语言，用于日常工作开发中的一些工具的编写" class="headerlink" title="3. 自学了python脚本语言，用于日常工作开发中的一些工具的编写"></a>3. 自学了python脚本语言，用于日常工作开发中的一些工具的编写</h3><h3 id="4-完成阅读了《代码大全》"><a href="#4-完成阅读了《代码大全》" class="headerlink" title="4. 完成阅读了《代码大全》"></a>4. 完成阅读了《代码大全》</h3><h3 id="5-搭建了适合自己使用的vim环境，使用tmux和zsh来进行开发工作"><a href="#5-搭建了适合自己使用的vim环境，使用tmux和zsh来进行开发工作" class="headerlink" title="5. 搭建了适合自己使用的vim环境，使用tmux和zsh来进行开发工作"></a>5. 搭建了适合自己使用的vim环境，使用tmux和zsh来进行开发工作</h3><span id="more"></span><h2 id="展望2015"><a href="#展望2015" class="headerlink" title="展望2015"></a>展望2015</h2><h3 id="1-实行每日时间轴计划，通过印象笔记记录每天的时间进程"><a href="#1-实行每日时间轴计划，通过印象笔记记录每天的时间进程" class="headerlink" title="1. 实行每日时间轴计划，通过印象笔记记录每天的时间进程"></a>1. 实行每日时间轴计划，通过印象笔记记录每天的时间进程</h3><h3 id="2-系统学习openGL相关知识，研究cocos2d-x的gl实现原理"><a href="#2-系统学习openGL相关知识，研究cocos2d-x的gl实现原理" class="headerlink" title="2. 系统学习openGL相关知识，研究cocos2d-x的gl实现原理"></a>2. 系统学习openGL相关知识，研究cocos2d-x的gl实现原理</h3><h3 id="3-独立完成一款休闲游戏，并成功上线"><a href="#3-独立完成一款休闲游戏，并成功上线" class="headerlink" title="3. 独立完成一款休闲游戏，并成功上线"></a>3. 独立完成一款休闲游戏，并成功上线</h3><h3 id="4-完成阅读书籍《openGL蓝宝书》、《Unix网络编程》"><a href="#4-完成阅读书籍《openGL蓝宝书》、《Unix网络编程》" class="headerlink" title="4. 完成阅读书籍《openGL蓝宝书》、《Unix网络编程》"></a>4. 完成阅读书籍《openGL蓝宝书》、《Unix网络编程》</h3><h3 id="5-完成背诵托福词汇，翻译10篇英文技术文献"><a href="#5-完成背诵托福词汇，翻译10篇英文技术文献" class="headerlink" title="5. 完成背诵托福词汇，翻译10篇英文技术文献"></a>5. 完成背诵托福词汇，翻译10篇英文技术文献</h3>]]></content>
      
      
      <categories>
          
          <category> 个人随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Cocos2d-x的lua绑定机制</title>
      <link href="/2015/09/18/2015-09-18-luabinding-in-cocos2dx/"/>
      <url>/2015/09/18/2015-09-18-luabinding-in-cocos2dx/</url>
      
        <content type="html"><![CDATA[<h2 id="关于tolua"><a href="#关于tolua" class="headerlink" title="关于tolua++"></a>关于tolua++</h2><h3 id="tolua如何工作"><a href="#tolua如何工作" class="headerlink" title="tolua如何工作"></a>tolua如何工作</h3><p><a href="https://github.com/LuaDist/toluapp">tolua++</a>是<a href="http://webserver2.tecgraf.puc-rio.br/~celes/tolua/">tolua</a>的扩展版本，一款能够极大地简化C/C++代码与Lua代码集成的工具。tolua基于一份简单干净的头文件，能够自动生成从Lua代码中访问C/C++特性的绑定代码，通过使用Lua API和标记方法工具，tolua来映射管理C/C++中的常量，外部变量，函数，类和方法来给Lua使用。</p><p>使用tolua通常要先建立pkg文件，里面包含对应C/C++头文件中能够被tolua++解析的声明，如常量、变量、函数以及类等。tolua++会根据pkg文件，来生成用于C/C++源文件与Lua交互的c/cpp文件，从而实现Lua中访问指定的C/C++代码。其中，无论是C函数还是C++对象的方法，都一律导出为静态函数。</p><h3 id="如何使用tolua"><a href="#如何使用tolua" class="headerlink" title="如何使用tolua"></a>如何使用tolua</h3><p>生成的tolua++可执行文件，支持一些可选选项，使用./tolua++ -h可进行查看。</p><ul><li><p>使用 <strong>-o</strong> 来指定生成的c/cpp文件</p><p> ./tolua++ -o myfile.c myfile.pkg</p></li><li><p>使用 <strong>-L</strong> 来在优先通过都dofile()来运行一份指定的Lua文件</p><p>  ./tolua++ -o myfile.c myfile.pkg -L rule.lua</p></li><li><p>使用 <strong>-n</strong> 来指定导出到lua的package</p><p>  ./tolua++ -n pkgname -o myfile.c myfile.pkg</p></li></ul><p> 绑定生成代码必须被编译并链接到应用程序，才能被Lua代码访问。每一个被解析的package文件代表要导出到Lua的包。默认情况，包名称就是输入文件的名称。用户可以指定一个不同的包名称。在tolua中，需要明确地初始化解析出的对应的包给Lua。在C/C++代码中我们应该调用初始化函数 <strong>int tolua_pkgname_open(void)</strong> 来进行初始化。其中 <em>pkgname</em> 代表被绑定的包的名称。</p><p> 更加详细的说明请参考<a href="http://webserver2.tecgraf.puc-rio.br/~celes/tolua/tolua-3.2.html">这里</a>。</p><span id="more"></span><h2 id="cocos2d-x的lua绑定机制"><a href="#cocos2d-x的lua绑定机制" class="headerlink" title="cocos2d-x的lua绑定机制"></a>cocos2d-x的lua绑定机制</h2><h3 id="版本2-x实现"><a href="#版本2-x实现" class="headerlink" title="版本2.x实现"></a>版本2.x实现</h3><p>在本节主要基于quick-cocos2d-x的2.x版本来进行讲解分析。在quick根目录的lib下，Lua绑定相关的代码放置于luabinding目录下，其中build.sh用来生成绑定文件。</p><pre><code>#!/bin/bashDIR=$(cd &quot;$(dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)&quot; &amp;&amp; pwd)TOLUA=&quot;$QUICK_COCOS2DX_ROOT/bin/mac/tolua++&quot;cd &quot;$DIR/&quot;$&#123;TOLUA&#125; -L &quot;$DIR/basic.lua&quot; -o &quot;$QUICK_COCOS2DX_ROOT/lib/cocos2d-x/scripting/lua/cocos2dx_support/LuaCocos2d.cpp&quot; Cocos2d.tolua</code></pre><p>根据脚本文件内容我们不难发现，其实就是执行了quick根目录bin/mac下的tolua++可执行文件，根据Cocos2d.tolua来解析生成LuaCocosd.cpp文件用于Lua代码中访问cocos2d-x的原生接口。其中还指定优先装载了basic.lua这个Lua文件，由于basic.lua文件篇幅较长，这里先不列出。其中basic.lua中重写实现了 <strong>post_output_hook(packag)</strong> 函数，该函数会在所有所有输出流写完之后执行。basic.lua通过这个函数主要进行了一些替换操作，以保证可以按照cocos2d-x自己的特殊需要修改输出的绑定生成cpp文件。</p><p>举个例子，cocos2d-x会在CCLuaValue.h中声明诸如LUA_STRING、LUA_FUNCTION和LUA_TABLE的类型，它们实际上就是int整型。为了防止tolua++将LUA_FUNCTION等解析成自定义类型，利用basic.lua中的replace函数将一些出现LUA_FUNCTION的地方都替换成了空的字符串。</p><p>正常如果我们想添加自己的c++代码并绑定给Lua使用，需要在quick-cocos2d-x中建立自己的tolua文件，该文件等同于之前的pkg文件，同样用于声明相关会被解析给Lua使用的常量、函数和类等。并建立一份build.sh脚本文件，内容如下：</p><pre><code>#!/usr/bin/env bashDIR=&quot;$( cd &quot;$( dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot; )&quot; &amp;&amp; pwd )&quot;cd &quot;$DIR&quot;OUTPUT_DIR=&quot;$DIR&quot;QUICK_COCOS2DX_ROOT=&quot;$DIR/../../..&quot;MAKE_LUABINDING=&quot;$QUICK_COCOS2DX_ROOT&quot;/bin/compile_luabinding.sh$MAKE_LUABINDING -d &quot;$OUTPUT_DIR&quot; test.tolua</code></pre><p>其中test.tolua是我们建立的pkg文件，里面声明了一个用于解析的C++类，其中类中有两个成员函数分别如下声明：</p><pre><code>string gzipDecompressStringLua(const char* data, int len);LUA_STRING gzipCompressStringLua(const char* data, int len);</code></pre><p>第一个gzipDecompressStringLua函数返回一个std::string给Lua使用，而第二个gzipCompressStringLua函数则返回LUA_STRING（实际上是int）给Lua层。执行刚刚新建立的build.sh，会自动生成一个cpp和h文件，里面就是根据tolua声明文件而对指定cpp文件解析生成的中间代码。首先会对Lua栈中的相关函数变量以及参数进行正确性地检查，没有问题后会根据tolua中的tolua_toXX系列函数生成调用所需的类的对象以及相关参数，最后调用c++对应的函数并获得返回值，通过tolua_pushXX系列函数将值压入Lua栈中。具体代码如下：</p><pre><code>static int tolua_jj_luabinding_JJZipUtil_gzipDecompressStringLua00(lua_State* tolua_S)&#123;#ifndef TOLUA_RELEASE    tolua_Error tolua_err;    if (        !tolua_isusertype(tolua_S,1,&quot;JJZipUtil&quot;,0,&amp;tolua_err) ||        !tolua_isstring(tolua_S,2,0,&amp;tolua_err) ||        !tolua_isnumber(tolua_S,3,0,&amp;tolua_err) ||        !tolua_isnoobj(tolua_S,4,&amp;tolua_err)    )    goto tolua_lerror;    else#endif    &#123;        JJZipUtil* self = (JJZipUtil*)  tolua_tousertype(tolua_S,1,0);        const char* data = ((const char*)  tolua_tostring(tolua_S,2,0));        int len = ((int)  tolua_tonumber(tolua_S,3,0));#ifndef TOLUA_RELEASE    if (!self) tolua_error(tolua_S,&quot;invalid &#39;self&#39; in function &#39;gzipDecompressStringLua&#39;&quot;, NULL);#endif    &#123;        string tolua_ret = (string)  self-&gt;gzipDecompressStringLua(data,len);        tolua_pushcppstring(tolua_S,(const char*)tolua_ret);    &#125;    &#125;    return 1;#ifndef TOLUA_RELEASE    tolua_lerror:    tolua_error(tolua_S,&quot;#ferror in function &#39;gzipDecompressStringLua&#39;.&quot;,&amp;tolua_err);    return 0;#endif&#125;</code></pre><p>而第二个返回LUA_STRING的函数，生成代码类似，只不过调用c++函数并获得返回值处的代码变成了没有处理返回值以及压入Lua栈的操作，需要我们在具体函数实现中调用相应的api来将指定的值压入栈中，并可以指定压入数据的长度，这样可以避免一些数据截断的情况的发生。对应生成代码如下：</p><pre><code>self-&gt;gzipCompressStringLua(data,len);</code></pre><p>回顾刚刚的build.sh，不难发现，实际上就是去调用quick-cocos2d-x的根目录下bin/compile_luabinding.sh脚本文件，该脚本又调用了bin/lib/compile_luabinding.php脚本文件，其中该目录下还有其他的php脚本文件，如compile_luabinding_functions.php文件中针对LUA_STRING等类型进行了特殊处理，与之前的cocos2d-x中原生处理LUA_FUNCTION的思路一致。</p><h3 id="版本3-x实现"><a href="#版本3-x实现" class="headerlink" title="版本3.x实现"></a>版本3.x实现</h3><p>在cocos2d-x 3.x版本后，针对Lua的绑定做了一些变动，开发者们不需要再针对每一个要解析绑定的cpp文件来编写pkg(tolua)文件了。在cocos2d-x/tools/tolua目录下，我们发现有许多ini为后缀的文件。根据这些ini配置文件，执行同一目录下的genbindings.py就会生成绑定代码cpp/hpp文件于cocos2d-x/cocos/scripting/lua-bindings/auto目录下。具体如何添加自定义的C++类绑定给Lua使用，请参考官方帮助文档<a href="http://www.cocos.com/doc/article/index?type=wiki&url=/doc/cocos-docs-master/manual/framework/native/wiki/how-to-use-bindings-generator/zh.md">如何使用 bindings-generator 自动生成 lua绑定</a>。</p><p>关于genbindings.py脚本文件主要做了以下几件事情：</p><ul><li>检查ndk以及llvm的支持</li><li>整理并将一些配置的环境变量值写入userconf.ini中</li><li>遍历cmd_args列表(其中key值就是待解析ini文件的名称)，并执行cocos2d-x/tools/bindings-generator/generator.py</li></ul><p>因此，具体的解析操作是在cocos2d-x/tools/bindings-generator/generator.py来实现的。bindings-generator下的genertor.py不单单用来处理Lua的绑定操作，也包括js的。根据分析源码，我们发现其支持集中传入参数：</p><ul><li><strong>-s</strong> 设置要转换的特定部分</li><li><strong>-t</strong> 指定目标虚拟机，会从TARGET.yaml中搜索</li><li><strong>-o</strong> 指定生成C++代码的输出目录</li><li><strong>-n</strong> 指定输出文件的名称，默认为.ini文件中的prefix选项</li></ul><p>在cocos2d-x/tools/bindings-generator/targets/lua目录下，放有conversions.yaml文件以及一个templates目录，根据conversions.yaml配置与templates下的模板文件，通过clang来进行语法和词法分析来生成绑定代码。</p><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><ul><li><a href="http://www.ibm.com/developerworks/cn/xml/x-cn-yamlintro/">YAML简介</a></li><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-pythcheetah/">使用Python和Cheetah构建和扩充模板</a></li><li><a href="http://eli.thegreenplace.net/2011/07/03/parsing-c-in-python-with-clang">Parsing C++ in Python with Clang</a></li><li><a href="http://szelei.me/code-generator/">Implementing a code generator with libclang</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Cocos2d-x </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cocos2d-x </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VIM下使用自定义代码片段</title>
      <link href="/2015/05/07/2015-05-07-vim-ultisnips/"/>
      <url>/2015/05/07/2015-05-07-vim-ultisnips/</url>
      
        <content type="html"><![CDATA[<h3 id="常见片段定义"><a href="#常见片段定义" class="headerlink" title="常见片段定义"></a>常见片段定义</h3><h4 id="片段内置默认文本-占位符可以包含其他UltiSnips元素"><a href="#片段内置默认文本-占位符可以包含其他UltiSnips元素" class="headerlink" title="片段内置默认文本(占位符可以包含其他UltiSnips元素)"></a>片段内置默认文本(占位符可以包含其他UltiSnips元素)</h4><pre><code>    snippet a    &lt;a href=&quot;$1&quot;$&#123;2: class=&quot;$&#123;3:link&#125;&quot;&#125;&gt;       $0    &lt;/a&gt;    endsnippet</code></pre><h4 id="单词开头自动大写"><a href="#单词开头自动大写" class="headerlink" title="单词开头自动大写"></a>单词开头自动大写</h4><pre><code>    snippet title &quot;Titelize in the Transformation&quot;    $&#123;1:a text&#125;    $&#123;1/\w+\s*/\u$0/g&#125;    endsnippet</code></pre><h4 id="条件替换"><a href="#条件替换" class="headerlink" title="条件替换"></a>条件替换</h4><pre><code>    snippet cond    $&#123;1:some_text&#125;$&#123;1/(o)|(t)|..*/(?1:ne)(?2:wo)/&#125;    endsnippet</code></pre><span id="more"></span><h4 id="部分单词提示-以触发字结尾即可触发"><a href="#部分单词提示-以触发字结尾即可触发" class="headerlink" title="部分单词提示(以触发字结尾即可触发)"></a>部分单词提示(以触发字结尾即可触发)</h4><pre><code>    snippet ri &quot;rizer&quot; i    rizer    endsnippet</code></pre><h4 id="有规律的表达式的触发提示"><a href="#有规律的表达式的触发提示" class="headerlink" title="有规律的表达式的触发提示"></a>有规律的表达式的触发提示</h4><pre><code>    snippet &quot;chap?t?e?r?&quot; &quot;Latex chapter&quot; rb    \section&#123;chapter&#125;        $0    \end&#123;chapter&#125;    endsnippet</code></pre><h4 id="特殊字符串触发提示"><a href="#特殊字符串触发提示" class="headerlink" title="特殊字符串触发提示"></a>特殊字符串触发提示</h4><pre><code>    snippet &quot; this is a trigger&quot; &quot;Multiword &amp; Whitespace&quot; r    Hello World    endsnippet</code></pre><h4 id="查看UltiSnips文档"><a href="#查看UltiSnips文档" class="headerlink" title="查看UltiSnips文档"></a>查看UltiSnips文档</h4><pre><code>    :help UltiSnips</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编辑器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP相关的术语总结</title>
      <link href="/2015/04/28/2015-04-28-tcp-term/"/>
      <url>/2015/04/28/2015-04-28-tcp-term/</url>
      
        <content type="html"><![CDATA[<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>传输控制协议(Transmission Controller Protocol)，是一个面向连接的协议，TCP套接字是一种流套接字，为用户进程提供可靠的全双工字节流。</p><hr><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>用户数据报协议(User Datagram Protocl)，是一个无连接协议，UDP套接字是一种数据报套接字，UDP数据报不能保证最终到达目的地，不保证各个数据报的先后顺序夸网络后保持不变，也不保证每个数据报只到达一次。</p><hr><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>地址解析协议(Address Resolution Protocol)，把一个IPv4地址映射成一个硬件地址(如以太网地址)。ARP通常用于诸如以太网、令牌环网和FDDI等广播网络，在点到点网络上并不需要。</p><hr><p>###RARP</p><p>反向地址解析协议(Reverse Address Resolution Protocol)，把一个硬件地址映射成IPv4地址，有时用于无盘节点的引导。</p><hr><span id="more"></span><h3 id="TCP建立连接的三次握手"><a href="#TCP建立连接的三次握手" class="headerlink" title="TCP建立连接的三次握手"></a>TCP建立连接的三次握手</h3><ol><li><p>服务器端准备好接受外来的连接，通过调用socket、bind和listen这3个函数来完成，称之为被动打开(passive open)。</p></li><li><p>客户端通过调用connect发起主动打开(active open)，客户端TCP发送一个**SYN(Synchronize Sequence Numbers)**，告诉服务器客户端将在连接中发送的数据的初始序列号。</p></li><li><p>服务器必须确认(<strong>ACK, Acknowledgement Number</strong>)，同时自己也得发送一个SYN，它含有服务器将在同一连接中发送的数据的初始序列号。</p></li><li><p>客户端必须确认服务器的SYN。</p></li></ol><hr><h3 id="TCP终止连接的四次握手"><a href="#TCP终止连接的四次握手" class="headerlink" title="TCP终止连接的四次握手"></a>TCP终止连接的四次握手</h3><ol><li><p>应用进程调用close，执行主动关闭(active close)。该端的TCP于是发送一个**FIN(Finish)**分节，表示数据发送完毕。</p></li><li><p>接收到这个FIN的对端执行被动关闭(passive close)。这个FIN由TCP确认，它的接收也作为一个文件结束符传递给接收端应用进程，因为FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。</p></li><li><p>接收到这个文件结束符的应用进程将调用close关闭它的套接字，发送一个FIN。</p></li><li><p>接收这个最终FIN的原发送端TCP(即执行主动关闭的那一端)确认这个FIN。</p></li></ol><hr><h3 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h3><p>该状态的持续时间是最长分节生命期(maximum segment lifetme, MSL, RFC1122建议值是2分钟, linux为30s)的两倍，有时称之为2MSL。TIME_WAIT状态可以可靠地实现TCP全双工连接的终止，允许老的重复分节在网络中消逝。TIME_WAIT确保有足够的时间让对端收到ACK，如果被动关闭的那方没有收到ACK，就会触发被动端触发重发FIN，并且保证有有足够的时间让这个连接不会跟后面的连接混在一起。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无处不在的Markdown</title>
      <link href="/2015/01/29/2015-01-29-markdown-everywhere/"/>
      <url>/2015/01/29/2015-01-29-markdown-everywhere/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是Markdown"><a href="#什么是Markdown" class="headerlink" title="什么是Markdown"></a>什么是Markdown</h3><p>Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。Markdown同时还是一个由Gruber编写的Perl脚本：Markdown.pl。它把用markdown语法编写的内容转换成有效的、结构良好的XHTML或HTML内容，并将左尖括号(‘&lt;’)和&amp;号替换成它们各自的字符实体引用。</p><hr><h3 id="语法简介"><a href="#语法简介" class="headerlink" title="语法简介"></a>语法简介</h3><ul><li><p>段落</p><blockquote><p>上下含有一个以上的空行，会被视为一个独立的段落。</p></blockquote></li><li><p>换行</p><blockquote><p>使用<code>&lt;br&gt;</code>标签，或是结尾处插入两个空格。</p></blockquote></li><li><p>标题</p><pre><code> 标题1(最高阶) ============= 标题2(第二高阶) -------------- # 这是H1 ## 这是H2 ###### 这是H6</code></pre></li></ul><span id="more"></span><ul><li><p>区块引用</p><blockquote><p>在行首或是段首使用区块<code>&gt;</code>来建立引用区块(注意上下要有空行)，引用区块内可以使用其他的Markdown语法。</p></blockquote></li><li><p>无序列表</p><pre><code> + One + Two</code></pre><p> 等同于</p><pre><code> * One * Two</code></pre><p> 等同于</p><pre><code> - One - Two</code></pre></li><li><p>有序列表</p><pre><code> 1. One 2. Two</code></pre></li><li><p>代码区块</p><blockquote><p>建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以。</p></blockquote></li><li><p>分割线</p><blockquote><p>在一行中使用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。</p></blockquote></li><li><p>强调</p><blockquote><p>使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个 * 或 _ 包起来的话，则会被转成 <code>&lt;strong&gt;</code>。</p></blockquote></li><li><p>链接</p><ul><li><p>行内式</p><pre><code>  [链接文字](http://jiayouxjh.github.io/ &quot;Title&quot;)</code></pre></li><li><p>参考式</p><pre><code>  [id]:  http://jiayouxjh.github.io/ &quot;Title&quot;  [链接文字][id]</code></pre></li></ul></li><li><p>图片</p><blockquote><p>与添加链接的方法类似，只需要在开头加上 ! 即可。Markdown目前不支持指定图片的宽高，可以使用<code>&lt;img&gt;</code>来实现。</p></blockquote></li><li><p>代码</p><blockquote><p>标记一小段行内代码，可以用反引号把它包起来（`），要在代码区段内插入反引号，可以用多个反引号来开启和结束代码区段。</p></blockquote></li></ul><hr><h3 id="使用Markdown同步印象笔记"><a href="#使用Markdown同步印象笔记" class="headerlink" title="使用Markdown同步印象笔记"></a>使用Markdown同步印象笔记</h3><ul><li><p>geeknote</p><blockquote><p>geeknote是一款使用python编写的命令行工具，可使用与Linux或是Mac的终端上。通过其提供的命令来实现使用Markdown编写修改指定账户下的相关笔记，包括同步指定目录。针对Evernote和印象笔记，geeknote有两个版本，用于不同服务器的同步工作。</p></blockquote></li><li><p>Evernote版</p><blockquote><p><a href="https://github.com/VitaliyRodnenko/geeknote" title="geeknote Evernote版">https://github.com/VitaliyRodnenko/geeknote</a></p></blockquote></li><li><p>印象笔记版</p><blockquote><p><a href="https://github.com/gmajian/geeknote" title="geeknote 印象笔记版">https://github.com/gmajian/geeknote</a></p></blockquote></li></ul><hr><h3 id="转换格式"><a href="#转换格式" class="headerlink" title="转换格式"></a>转换格式</h3><blockquote><p>使用强大的pandoc，Github地址 <a href="https://github.com/jgm/pandoc" title="pandoc">https://github.com/jgm/pandoc</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用开源协议介绍</title>
      <link href="/2015/01/24/2015-01-24-opensource-license-intro/"/>
      <url>/2015/01/24/2015-01-24-opensource-license-intro/</url>
      
        <content type="html"><![CDATA[<h3 id="Apache-2-0"><a href="#Apache-2-0" class="headerlink" title="Apache-2.0"></a><strong>Apache-2.0</strong></h3><ul><li><em>Apache Lience</em></li><li>支持商业用途，允许使用者修改和重新发布代码(以其他协议形式)</li><li>协议规则<ul><li>需要给代码的用户一份Apache Lience</li><li>如果修改了代码，需要在被修改的文件中说明</li><li>在延伸的代码中（修改或衍生的代码）需要带有原来代码中的协议、商标、专利声明和其他原来作者规定需要包含的说明</li><li>如果再发布的产品中包含了Notice文件，则需要在Notice文件中带有Apache Lience</li></ul></li></ul><h3 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a><strong>BSD</strong></h3><ul><li><em>Berkerley Software Distribution</em></li><li>支持商业用途，可使用、修改源码</li><li>协议规则<ul><li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议</li><li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档那个和版权声明中包含原来代码中的BSD协议</li><li>不可以用开源代码的“作者/机构的名字”或“原来产品的名字”做市场推广</li></ul></li></ul><span id="more"></span><h3 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a><strong>GPL</strong></h3><ul><li><em>GNU General Public License</em></li><li>不支持商业用途，源码必须开放</li><li>协议规则<ul><li>确保软件自始至终都以开放源代码形式发布，保护开发成果不被窃取用作商业发售</li><li>可以去掉所有原作的版权信息，只要保持开源，并且随源代码、二进制版附上GPL的许可证</li><li>无论软件以何种形式发布，都必须同时附上源代码</li><li>开发或维护遵循GPL协议开发的软件的公司或个人，可以对使用者收取一定的___服务费用___</li></ul></li></ul><h3 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a><strong>LGPL</strong></h3><ul><li><em>GNU Library or “Lesser” General Public License</em></li><li>支持商业用途，但不可修改源码</li><li>协议规则<ul><li>允许商业软件通过类库引用(link)的方式使用LGPL类库而不需要开源商业软件的代码</li><li>修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议</li></ul></li></ul><h3 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a><strong>MIT</strong></h3><ul><li><em>Massachusetts Institute of Technology</em></li><li>支持商业用途，可使用、修改和出售源码</li><li>协议规则<ul><li>必须在发行版里包含原许可协议的声明，无论是以二进制发布的还是以源代码发布</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Python中使用Clang来解析C++【翻译】</title>
      <link href="/2014/11/29/2015-parse-cpp-in-python/"/>
      <url>/2014/11/29/2015-parse-cpp-in-python/</url>
      
        <content type="html"><![CDATA[<p>   <a href="http://eli.thegreenplace.net/2011/07/03/parsing-c-in-python-with-clang">原文地址</a></p><p>Clang的API发展十分迅速，其中也包括libclang和Python绑定。因此，本次推送中的示例可能不再起作用。如果想要那些基于最新的Clang的工作示例，请检查我在Github上的<a href="https://github.com/eliben/llvm-clang-samples">llvm-clang-samples repository仓库</a>。</p><p>对于那些需要在Python中去解析和分析C代码的人，在发现<a href="https://github.com/eliben/pycparser">pycparser</a>后一定会很兴奋。然而，如果变成是去解析C++，pycparser并不是好的解决办法。当我被问及关于在pycparser中增加支持C++的计划时，我的回答通常是 – 没有这样的计划，你应该去别处找找。尤其地，是在<a href="http://clang.llvm.org/">Clang</a>中。</p><p>Clang是一款针对C，C++和Object C的编译器前端。它是由Apple支持的一款具有自由协议的开源项目，并使用它们自己的工具。连同它的父项目 – LLVM编译器后端，Clang渐渐成为一款gcc的强大替代品。在Clang（包括LLVM）身后有着一流的开发团队，并且它的代码在开源环境下也是C++代码中设计最好的之一。Clang的发展十分积极，密切关注着最新的C++标准。</p><p>于是当我被问关于解析C++的问题的时候，我的回答总是Clang。诚然，它还存在着一些小问题。人们喜欢pycparser因为它是Python实现的，而Clang的API接口是C++，并不是最极客并友好的语言，退一步来说。</p><span id="more"></span><h3 id="libclang"><a href="#libclang" class="headerlink" title="libclang"></a>libclang</h3><p>下面进入libclang。不太久之前，Clang的团队明智地意识到Clang并不仅仅可以用于编译器，也可以是分析C/C++/ObjC代码的工具。事实上，Apple的自研Xcode开发工具就是用Clang作为内置库来进行代码提示，交叉引用，等等。</p><p>能使Clang如此被利用的组件我们称之为libclang。它是C API编写的，并且Clang团队郑重声明保证其稳定性，允许使用者在抽象语法树（AST）的等级上去检查解析代码。</p><p>更多的技术上来讲，libclang是一个通过使用面向公众的API来对Clang进行包装的共享库，并只定义在一份C语言头文件中：clang/include/clang-c/Index.h 。</p><h3 id="Python绑定到libclang"><a href="#Python绑定到libclang" class="headerlink" title="Python绑定到libclang"></a>Python绑定到libclang</h3><p>libclang于 <em>clang/bindings/python</em> 中附带了Python绑定，位于 <em>clang.cindex</em> 模块中。这个模块依赖于 <em>ctypes</em> 去装载动态的libclang库，并试图尽可能地去封装libclang作为Python API接口。</p><h3 id="文档？"><a href="#文档？" class="headerlink" title="文档？"></a>文档？</h3><p>非常不幸，目前libclang的相关文档以及Python绑定的状态十分糟糕。官方文档会根据源代码而进行开发（自动生成Doxygen HTML）。此外，我所能找到的所有在线文档只有一份<a href="http://llvm.org/devmtg/2010-11/Gregor-libclang.pdf">演示</a>和一些来自Clang开发邮件列表中过时的邮件信息。</p><p>好的一方面，即使你只浏览了一遍 <strong>Index.h</strong> 头文件也能记住它试图要实现什么，它的API并不难懂（具体实现也是一样易懂，哪怕你对Clang的内部只熟悉一点）。另一个需要看的地方是 <strong>clang/tools/c-index-test</strong> 工具，它是用来测试API接口并示例它们该如何使用。</p><p>对于Python绑定，也完全没有任何文档，除了它发布的源代码和一些相关示例。因此，我希望这篇文章能够起到帮助！</p><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>设置使用Python绑定很简单：</p><ul><li><p>你的脚本需要能够找到 <strong>clang.cindex</strong> 模块。所以要适当地复制它或建立 <strong>PYTHONPATH</strong> 来指向它。</p></li><li><p><strong>clang.cindex</strong> 需要能够找到 <strong>libclang.so</strong> 共享库。取决于你如何构建/安装Clang，你需要适当地拷贝它或是建立 <strong>LD_LIBRARY_PATH</strong> 来指向它的位置。在Windows操作系统，则是 <strong>libclang.dll</strong> 并且需要设置到 <strong>PATH</strong> 环境变量中去。</p></li></ul><p>准备就绪后，要去调用 <strong>import clang.cindex</strong> 并开始使用。</p><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p>让我们开始一段简单的示例。下面的脚本使用 <strong>libclang</strong> 的Python绑定来找到一个给定文件中的所有引用类型：</p><pre><code>#!/usr/bin/env python&quot;&quot;&quot; Usage: call with &lt;filename&gt; &lt;typename&gt;&quot;&quot;&quot;import sysimport clang.cindexdef find_typerefs(node, typename):    &quot;&quot;&quot; Find all references to the type named &#39;typename&#39;    &quot;&quot;&quot;    if node.kind.is_reference():        ref_node = clang.cindex.Cursor_ref(node)        if ref_node.spelling == typename:            print &#39;Found %s [line=%s, col=%s]&#39; % (                typename, node.location.line, node.location.column)    # Recurse for children of this node    for c in node.get_children():        find_typerefs(c, typename)index = clang.cindex.Index.create()tu = index.parse(sys.argv[1])print &#39;Translation unit:&#39;, tu.spellingfind_typerefs(tu.cursor, sys.argv[2])</code></pre><p>假设我们在下面这段C++代码中调用它：</p><pre><code>class Person &#123;&#125;;class Room &#123;public:    void add_person(Person person)    &#123;        // do stuff    &#125;private:    Person* people_in_room;&#125;;template &lt;class T, int N&gt;class Bag&lt;T, N&gt; &#123;&#125;;int main()&#123;    Person* p = new Person();    Bag&lt;Person, 42&gt; bagofpersons;    return 0;&#125;</code></pre><p>执行去查找 <strong>Persion</strong> 引用类型，我们会得到：</p><pre><code>Translation unit: simple_demo_src.cppFound Person [line=7, col=21]Found Person [line=13, col=5]Found Person [line=24, col=5]Found Person [line=24, col=21]Found Person [line=25, col=9]</code></pre><h3 id="理解它是如何工作的"><a href="#理解它是如何工作的" class="headerlink" title="理解它是如何工作的"></a>理解它是如何工作的</h3><p>为了理解这个例子做了什么，我们需要明白它内部运作的3个层次：</p><ul><li>概念层次 – 我们从要被解析的源代码获取的信息是什么，并且它是如何储存的；</li><li>libclang层次 – <strong>libclang</strong> 的正式C API，要比Python绑定代码更容易阅读，虽然只在代码中有一些备注；</li><li>Python绑定层次，这是我们直接调用的。</li></ul><h4 id="创建索引并解析代码"><a href="#创建索引并解析代码" class="headerlink" title="创建索引并解析代码"></a>创建索引并解析代码</h4><p>我们需要在最开始时添加如下代码：</p><pre><code>index = clang.cindex.Index.create()tu = index.parse(sys.argv[1])</code></pre><p>一个”index”代表一组编译和链接在一起的翻译单元。我们需要一些分组翻译单元的方法，如果试图理解它们的话。举例来说，我们可能想要找到一些定义在头文件中的引用类型，以及在一些其他的源文件中。 <strong>Index.create()</strong> 调用C API函数 __clang_createIndex__。</p><p>接下来，我们使用 <strong>Index’s parse</strong> 方法来解析一个文件中单独的翻译单元。调用 __clang_parseTranslationUnit__，一个在C API中的关键函数。它的注释提到：</p><blockquote><p> 这个程序是Clang C API中的主要入口，提供将一份源文件解析成一个翻译单元的功能，并且能查询API中其他的函数。</p></blockquote><p>这是一个强大的函数 – 它能可选择性地正常接受全套标识并传到命令行编译器。它返回一个封装了的 <strong>CXTranslationUnit</strong> 对象，作为一个封装了Python绑定的翻译单元。这个翻译单元能够被查询，例如翻译单元的名字可以通过 <strong>spelling</strong> 属性表示：</p><pre><code>print &#39;Translation unit:&#39;, tu.spelling</code></pre><p>然而，它最重要的属性是 – __cursor__。一个 <em>cursor</em> 是libclang中的关键抽象，它表示一个被解析翻译单元的抽象语法树中的一些节点。在一个单一抽象下的程序中，cursor整合不同类型的实体，提供一组常见的操作，如获取它的位置和子cursor。 <strong>TranslationUnit.cursor</strong> 返回一个翻译单元最高层级的cursor，作为索引它的抽象语法树的声明点。</p><h4 id="使用curosrs进行工作"><a href="#使用curosrs进行工作" class="headerlink" title="使用curosrs进行工作"></a>使用curosrs进行工作</h4><p>Python绑定将 <strong>libclang</strong> 中的cursor封装成 <strong>Cursor</strong> 对象。它有许多属性，其中最有趣的包括：</p><ul><li><strong>kind</strong> – 一个枚举指定了这个curosr指向的抽象语法树节点的种类；</li><li><strong>spelling</strong> – 节点的源代码名称</li><li><strong>location</strong> – 被解析节点的源代码位置</li><li><strong>get_children</strong> – 它的子节点</li></ul><p> <strong>get_children</strong> 需要专门说明一下，因为这是一个在C和Python的API接口分歧上的特殊点。</p><p> <strong>libclang</strong> C API 基于访问者想法。根据给定的cursor走到抽象语法树，用户代码提供了一个针对 <strong>clang_visitChildren</strong> 的回调函数。然后在一个给定的抽象语法树的所有子节点上来调用这个函数。</p><p>而另一方面的Python绑定，会封装在内部访问，通过 <strong>Cursor.get_children</strong> 提供一个Python化的迭代API，返回一个指定cursor的子节点。它仍然可以通过Python来直接访问最原始的API接口，但是使用 <strong>get_children</strong> 更加地方便。在我们的例子中，我们使用 <strong>get_children</strong> 来递归访问一个节点的所有子节点：</p><pre><code> for c in node.get_children():    find_typerefs(c, typename)</code></pre><h4 id="Python绑定的一些局限性"><a href="#Python绑定的一些局限性" class="headerlink" title="Python绑定的一些局限性"></a>Python绑定的一些局限性</h4><p>不幸的是，Python绑定还不够成熟并存在一些缺陷，因为它是一项正在进行中的工作。举一个例子，假设我们想要找到和记录这个文件中的所有函数调用：</p><pre><code>bool foo()&#123;    return true;&#125;void bar()&#123;    foo();    for (int i = 0; i &lt; 10; ++i)        foo();&#125;int main()&#123;    bar();    if (foo())        bar();&#125;</code></pre><p>让我们写下这段代码：</p><pre><code>import sysimport clang.cindexdef callexpr_visitor(node, parent, userdata):    if node.kind == clang.cindex.CursorKind.CALL_EXPR:        print &#39;Found %s [line=%s, col=%s]&#39; % (                node.spelling, node.location.line, node.location.column)    return 2 # means continue visiting recursivelyindex = clang.cindex.Index.create()tu = index.parse(sys.argv[1])clang.cindex.Cursor_visit(        tu.cursor,        clang.cindex.Cursor_visit_callback(callexpr_visitor),        None)</code></pre><p>这次直接使用 <strong>libclang</strong> 的访问API，结果如下：</p><pre><code>Found None [line=8, col=5]Found None [line=10, col=9]Found None [line=15, col=5]Found None [line=16, col=9]Found None [line=17, col=9]</code></pre><p>既然被记录的位置是正确的，那为什么节点的名字会是 <strong>Node</strong> 呢？仔细研究过libclang的代码后发现，我们不应该来打印 <em>spelling</em> ，而应该是 <em>display</em> 。在C API中它意味着 <strong>clang_getCursorDisplayName</strong> 而不是 <strong>clang_getCursorSpelling</strong> 。但是，Python绑定并没有暴露 <strong>clang_getCursorDisplayName</strong> 接口！</p><p>然而，我们不应该就此放弃。Python绑定的相关源代码十分地直截了当，并且很容易通过 <strong>ctypes</strong> 来在C API中开放额外的函数。只要在 <strong>bindings/python/clang/cindex.py</strong> 中添加如下几行：</p><pre><code>Cursor_displayname = lib.clang_getCursorDisplayNameCursor_displayname.argtypes = [Cursor]Cursor_displayname.restype = _CXStringCursor_displayname.errcheck = _CXString.from_result</code></pre><p>现在我们可以使用 __Cursor_displayname__，在脚本中通过 <strong>clang.cindex.Cursor_displayname(node)</strong> 来代替 <strong>node.spelling</strong> 。这样可以得到我们想要的输出结果：</p><pre><code>Found foo [line=8, col=5]Found foo [line=10, col=9]Found bar [line=15, col=5]Found foo [line=16, col=9]Found bar [line=17, col=9]</code></pre><p> _更新提示（06.07.2011）_：来自这篇文章的灵感，我向Clang项目中提交了关于开放 <strong>Cursor_displayname</strong> 接口的代码，也修复了一些在Python绑定中的其他问题。它已经在Clang的核心开发版本134460中被提交，并且现在应该在主干trunk上可用。</p><h4 id="libclang的一些局限性"><a href="#libclang的一些局限性" class="headerlink" title="libclang的一些局限性"></a>libclang的一些局限性</h4><p>综上所述，Python绑定的一些局限性相对容易客服。自从 <strong>libclang</strong> 提供了一个简单易行的C API，这仅仅就是适当使用 <strong>ctypes</strong> 结构来开放暴露附加函数的问题而已。对于任何有些Python经验的人来说，这都不是一个大问题。</p><p>然而一些 <strong>libclang</strong> 本身的局限性，例如，假设我们想要找到一段代码中的所有返回语句，结果发现通过当前 <strong>libclang</strong> 的API是办不到的。大致浏览 <strong>Index.h</strong> 就会发现其原因。</p><p> <strong>enum CXCursorKind</strong> 枚举了我们在 <strong>libclang</strong> 中可能遇到的cursor节点的种类。下面是这部分相关的代码：</p><pre><code>/* Statements */CXCursor_FirstStmt                     = 200,/** * \brief A statement whose specific kind is not exposed via this * interface. * * Unexposed statements have the same operations as any other kind of * statement; one can extract their location information, spelling, * children, etc. However, the specific kind of the statement is not * reported. */CXCursor_UnexposedStmt                 = 200,/** \brief A labelled statement in a function. * * This cursor kind is used to describe the &quot;start_over:&quot; label statement in * the following example: * * \code *   start_over: *     ++counter; * \endcode * */CXCursor_LabelStmt                     = 201,CXCursor_LastStmt                      = CXCursor_LabelStmt,</code></pre><p>忽略用于正确性测试的占位符 <strong>CXCursor_FirstStmt</strong> 和 <strong>CXCursor_LastStmt</strong> ，这唯一需要注意的是lable语句。所有其他的声明语句将会被 <strong>CXCursor_UnexposedStmt</strong> 所替代。</p><p>去理解这个缺陷的原理，有建设性的思考是 <strong>libclang</strong> 的主要目标。目前，API主要用于集成开发环境当中，我们想要知道一切类型和引用符号，但不用明确关心我们看到的声明或是语句的种类。</p><p>值得庆幸的是，从Clang的邮件开发列表讨论组中可以收集到这种局限性并非蓄意而为之。在 <strong>libclang</strong> 中根据需要添加的东西，显然没有一个需要 <strong>libclang</strong> 来辨别声明种类的不同，因此没有人增加这个特性。如果它对某人来说足够重要，他可以随时在邮件列表中提出一个修补补丁。特别是，这个具体的缺陷（缺少声明种类）是很容易被解决的。看看在 <strong>libclang/CXCursor.cpp</strong> 中的 <strong>cxcursor::MakeCXCursor</strong> ，很明显找到这些”种类”是如何生成的：</p><pre><code>CXCursor cxcursor::MakeCXCursor(Stmt *S, Decl *Parent,                            CXTranslationUnit TU) &#123;      assert(S &amp;&amp; TU &amp;&amp; &quot;Invalid arguments!&quot;);      CXCursorKind K = CXCursor_NotImplemented;      switch (S-&gt;getStmtClass()) &#123;      case Stmt::NoStmtClass:        break;      case Stmt::NullStmtClass:      case Stmt::CompoundStmtClass:      case Stmt::CaseStmtClass:      ... // many other statement classes      case Stmt::MaterializeTemporaryExprClass:        K = CXCursor_UnexposedStmt;        break;      case Stmt::LabelStmtClass:        K = CXCursor_LabelStmt;            break;      case Stmt::PredefinedExprClass:      .. //  many other statement classes      case Stmt::AsTypeExprClass:        K = CXCursor_UnexposedExpr;        break;      .. // more code  &#125;</code></pre><p>这是在 <strong>Stmt.getStmtClass()</strong> 中的一个简单而巨大的switch语句，并且仅对 <strong>Stmt::LabelStmtClass</strong> 有一种非 <strong>CXCursor_UnexposedStmt</strong> 类型。所以建议添加的”类型”不要是特别重要的：</p><ol><li>向 <strong>CXCursorKind</strong> 添加另一个枚举值，在 <strong>CXCursor_FirstStmt</strong> 和 <strong>CXCurosr_LastStmt</strong> 之间；</li><li>在 <strong>cxcursor::MakeCXCursor</strong> 中的switch语句中添加另一份条件case以识别适合的类和返回值种类；</li><li>在Python绑定中暴露相关枚举值。</li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>希望这篇文章介绍 <strong>libclang</strong> 的Python绑定的文章能够起到帮助。尽管这些组件缺乏外部文档，但它们被很好的编写和注释，并且源代码足够的浅显易懂。</p><p>记住这些积极发展、并包装在十分强大的C/C++/ObjC的解析引擎里的API，显得十分重要。仅代表个人观点，Clang是当下最新的C++解析库中最好的选择，没有之一。</p><p>在 <strong>libclang</strong> 本身以及Python绑定中存在着一些美中不足的小限制。这些都是最近相对除了Clang之外， <strong>libclang</strong> 的附带结果，毕竟它还是一个非常年轻的项目。</p><p>幸运的是，希望我这篇文章能够告诉你们这些限制并非极度难以解决的。仅需要少量Python和C的专业知识，就能够扩展Python绑定，并且一点对Clang的理解也可以增强奠定 <strong>libclang</strong> 本身。另外， <strong>libclang</strong> 仍然在积极地发展当中。我十分确信这些API将会随着时间的推移而持续改进，并且限制也会越来越少。</p>]]></content>
      
      
      <categories>
          
          <category> 编程相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的Git操作</title>
      <link href="/2014/11/07/2014-11-07-github-operation/"/>
      <url>/2014/11/07/2014-11-07-github-operation/</url>
      
        <content type="html"><![CDATA[<h3 id="初始化操作"><a href="#初始化操作" class="headerlink" title="初始化操作"></a>初始化操作</h3><pre><code>git config -global user.name &lt;name&gt;     #设置提交者名字git config -global user.email &lt;email&gt;   #设置提交者邮箱git config -global core.editor &lt;editor&gt; #设置默认文本编辑器git config -global merge.tool &lt;tool&gt;    #设置解决合并冲突时差异分析工具</code></pre><h3 id="修改和提交"><a href="#修改和提交" class="headerlink" title="修改和提交"></a>修改和提交</h3><pre><code>git add .                       #添加所有改动过的文件git add &lt;file&gt;                  #添加指定的文件git mv &lt;old&gt; &lt;new&gt;              #文件重命名git rm &lt;file&gt;                   #删除文件git rm -cached &lt;file&gt;           #停止跟踪文件但不删除git commit -m &lt;file&gt;            #提交指定文件git commit -m &quot;commit message&quot;  #提交所有更新过的文件git commit -amend               #修改最后一次提交git commit -C HEAD -a -amend    #增补提交</code></pre><span id="more"></span><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><pre><code>git log            #查看提交历史git log -p &lt;file&gt;  #查看指定文件的提交历史git log HEAD       #查看已经add但还没有commit的文件git blame &lt;file&gt;   #以列表方式查看指定文件的提交历史git status         #查看当前状态git diff           #查看变更内容</code></pre><h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><pre><code>git reset --hard HEAD               #撤销工作目录中所有未提交文件的修改内容git checkout HEAD &lt;file1&gt; &lt;file2&gt;  #撤消指定的未提交文件的修改内容git checkout HEAD .                #撤消所有文件git revert &lt;commit&gt;                #撤消指定的提交</code></pre><h3 id="分支和标签"><a href="#分支和标签" class="headerlink" title="分支和标签"></a>分支和标签</h3><pre><code>git branch                     #显示所有本地分支git checkout &lt;branch/tagname&gt;  #切换到指定分支或标签git branch &lt;new-branch&gt;        #创建新分支git branch -d &lt;branch&gt;         #删除本地分支git branch -va                 #查看远程仓库的其他分支git checkout -b a origin/a     #切换远程分支git tag                        #列出所有本地标签git tag &lt;tagname&gt;              #基于最新提交创建标签git tag -d &lt;tagname&gt;           #删除标签git merge &lt;branch&gt;             #合并指定分支到当前分支git rebase &lt;branch&gt;            #衍合指定分支到当前分支</code></pre><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><pre><code>git remote -v                           #查看远程版本库信息git remote show &lt;remote&gt;                #查看指定远程版本库信息git remote add &lt;remote&gt; &lt;url&gt;           #添加远程版本库git fetch &lt;remote&gt;                      #从远程库获取代码git pull &lt;remote&gt; &lt;branch&gt;              #下载代码及快速合并git push &lt;remote&gt; &lt;branch&gt;              #上传代码及快速合并git push &lt;remote&gt; : &lt;branch&gt;/&lt;tagname&gt;  #删除远程分支或标签git push -tags                          #上传所有标签</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中常用的相关文件操作</title>
      <link href="/2014/11/05/2014-11-05-python-file-io/"/>
      <url>/2014/11/05/2014-11-05-python-file-io/</url>
      
        <content type="html"><![CDATA[<h3 id="获取当前工作目录"><a href="#获取当前工作目录" class="headerlink" title="获取当前工作目录"></a>获取当前工作目录</h3><pre><code>os.getcwd()</code></pre><h3 id="获取执行脚本所在路径"><a href="#获取执行脚本所在路径" class="headerlink" title="获取执行脚本所在路径"></a>获取执行脚本所在路径</h3><pre><code>sys.path[0]</code></pre><h3 id="判断目录是否存在"><a href="#判断目录是否存在" class="headerlink" title="判断目录是否存在"></a>判断目录是否存在</h3><pre><code>os.path.exists(path)  返回false表示不存在</code></pre><h3 id="删除一个非空的目录"><a href="#删除一个非空的目录" class="headerlink" title="删除一个非空的目录"></a>删除一个非空的目录</h3><pre><code>import shutilshutil.rmtree(path)</code></pre><span id="more"></span><h3 id="创建单个（多个）目录"><a href="#创建单个（多个）目录" class="headerlink" title="创建单个（多个）目录"></a>创建单个（多个）目录</h3><pre><code>os.mkdir(name)os.makedirs(&quot;dir1/dir2&quot;)</code></pre><h3 id="判断文件是否存在"><a href="#判断文件是否存在" class="headerlink" title="判断文件是否存在"></a>判断文件是否存在</h3><pre><code>os.path.isfile(path)</code></pre><h3 id="删除一个文件"><a href="#删除一个文件" class="headerlink" title="删除一个文件"></a>删除一个文件</h3><pre><code>os.remove(path)</code></pre><h3 id="获取文件大小"><a href="#获取文件大小" class="headerlink" title="获取文件大小"></a>获取文件大小</h3><pre><code>os.path.getsize(filename)</code></pre><h3 id="格式化输出字符串"><a href="#格式化输出字符串" class="headerlink" title="格式化输出字符串"></a>格式化输出字符串</h3><pre><code>&#39;Test str &#123;key1&#125; &#123;key2&#125;&#39;.format(key1=&#39;hello&#39;, key2=&#39;world&#39;)&quot;My name is %s and weight is %d kg!&quot; % (&#39;Zara&#39;, 21)</code></pre><h3 id="获取格式化时间"><a href="#获取格式化时间" class="headerlink" title="获取格式化时间"></a>获取格式化时间</h3><pre><code>import timetime.strftime(&#39;%Y-%m-%d-%H:%M:%S&#39;,time.localtime(time.time()))</code></pre><h3 id="计算文件的MD5值"><a href="#计算文件的MD5值" class="headerlink" title="计算文件的MD5值"></a>计算文件的MD5值</h3><pre><code>from hashlib import md5m = md5()file = open(path, &#39;rb&#39;)m.update(file.read())file.close()md5_str = m.hexdigest()</code></pre><h3 id="按行读取配置文件内容"><a href="#按行读取配置文件内容" class="headerlink" title="按行读取配置文件内容"></a>按行读取配置文件内容</h3><pre><code>fp = open(path, &#39;r&#39;)while 1:    line = fp.readline().strip(&#39;\r\n&#39;)    if not line:        break    print linefp.close()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cocos2d-x 3.x 中用到的c11特性</title>
      <link href="/2014/11/03/2014-11-03-c11-with-cocos2dx/"/>
      <url>/2014/11/03/2014-11-03-c11-with-cocos2dx/</url>
      
        <content type="html"><![CDATA[<h2 id="回调函数指针传递"><a href="#回调函数指针传递" class="headerlink" title="回调函数指针传递"></a>回调函数指针传递</h2><p>在从ccMacros.h中定义了CC_CALLBACK_n系列宏，其中n为0~4，表示包裹回调函数指针的参数个数。</p><p>以触摸事件为例：</p><pre><code>void Test::initListener()&#123;    auto listener = EventListenerTouchOneByOne::create();    listener-&gt;onTouchBegan = CC_CALLBACK_2(Test::onTouchBegan, this);    listener-&gt;onTouchMoved = CC_CALLBACK_2(Test::onTouchMoved, this);    listener-&gt;onTouchEnded = CC_CALLBACK_2(Test::onTouchEnded, this);    listener-&gt;onTouchCancelled = CC_CALLBACK_2(Test::onTouchCancelled, this);&#125;</code></pre><span id="more"></span>><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>语法格式：<a href="%E5%8F%82%E6%95%B0">捕捉块</a>-&gt;返回值类型{主体}</p><p>其中捕捉块是指显示指定闭包中函数需要捕捉的变量，其中包括6种表达方式：</p><p>[=]表示通过值传递捕捉所有变量;</p><p>[&amp;]表示通过引用传递捕捉所有变量;</p><p>[var]表示通过值捕捉变量var,不捕捉其他变量;</p><p>[&amp;var]表示通过引用捕捉var,不捕捉其他变量;</p><p>[=,&amp;var]表示默认通过值捕捉，变量var引用捕捉;</p><p>[&amp;,var]表示默认通过引用捕捉，变量var值捕捉</p><pre><code>void TestLayer::initListener(Node* node)&#123;    int var = 10;    auto listener = EventListenerTouchOneByOne::create();    listener-&gt;onTouchBegan = [&amp;](Touch* touch, Event* event)-&gt;bool &#123;        var = 20;        return true;    &#125;    CCLOG(&quot;var : %d&quot;, var);    this-&gt;_eventDispatcher-&gt;addEventListenerWithSceneGraphPriority(listener, node);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> cocos2d-x </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocos2d-x </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
