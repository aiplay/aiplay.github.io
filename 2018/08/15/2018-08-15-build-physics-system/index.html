<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aiplay.studio","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":15,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="PhysX物理引擎PhysX是一套由AGEIA公司开发的物理运算引擎(后被NVIDIA收购)，简而言之，就是令虚拟世界中的物体运动符合真实世界的物理定律，以使游戏更加富有真实感。PhysX可以由CPU计算，但其程序本身在设计上还可以调用独立的浮点处理器（例如GPU和PPU）来计算，也正因为如此，它可以轻松完成像流体力学模拟那样的大计算量的物理模拟计算。 目前最火热的两款商业游戏引擎Unreal和U">
<meta property="og:type" content="article">
<meta property="og:title" content="使用PhysX构建简单的物理系统">
<meta property="og:url" content="http://aiplay.studio/2018/08/15/2018-08-15-build-physics-system/index.html">
<meta property="og:site_name" content="爱丸游戏工作室">
<meta property="og:description" content="PhysX物理引擎PhysX是一套由AGEIA公司开发的物理运算引擎(后被NVIDIA收购)，简而言之，就是令虚拟世界中的物体运动符合真实世界的物理定律，以使游戏更加富有真实感。PhysX可以由CPU计算，但其程序本身在设计上还可以调用独立的浮点处理器（例如GPU和PPU）来计算，也正因为如此，它可以轻松完成像流体力学模拟那样的大计算量的物理模拟计算。 目前最火热的两款商业游戏引擎Unreal和U">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://7xlmp2.com1.z0.glb.clouddn.com/2018-08-15%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F.png">
<meta property="og:image" content="http://7xlmp2.com1.z0.glb.clouddn.com/2018-08-15-physx_actor_tree.png">
<meta property="og:image" content="http://7xlmp2.com1.z0.glb.clouddn.com/2018-08-15-relation_colliders_pxshape.png">
<meta property="og:image" content="http://7xlmp2.com1.z0.glb.clouddn.com/2018-08-15-timeline-with-update.png">
<meta property="article:published_time" content="2018-08-14T16:00:00.000Z">
<meta property="article:modified_time" content="2021-11-14T10:29:52.225Z">
<meta property="article:author" content="xujh">
<meta property="article:tag" content="physics">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://7xlmp2.com1.z0.glb.clouddn.com/2018-08-15%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F.png">

<link rel="canonical" href="http://aiplay.studio/2018/08/15/2018-08-15-build-physics-system/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>使用PhysX构建简单的物理系统 | 爱丸游戏工作室</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">爱丸游戏工作室</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://aiplay.studio/2018/08/15/2018-08-15-build-physics-system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="xujh">
      <meta itemprop="description" content="爱生活 | 爱丸子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="爱丸游戏工作室">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          使用PhysX构建简单的物理系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-15 00:00:00" itemprop="dateCreated datePublished" datetime="2018-08-15T00:00:00+08:00">2018-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-14 18:29:52" itemprop="dateModified" datetime="2021-11-14T18:29:52+08:00">2021-11-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">游戏开发</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="PhysX物理引擎"><a href="#PhysX物理引擎" class="headerlink" title="PhysX物理引擎"></a>PhysX物理引擎</h3><p>PhysX是一套由AGEIA公司开发的物理运算引擎(后被NVIDIA收购)，简而言之，就是令虚拟世界中的物体运动符合真实世界的物理定律，以使游戏更加富有真实感。PhysX可以由CPU计算，但其程序本身在设计上还可以调用独立的浮点处理器（例如GPU和PPU）来计算，也正因为如此，它可以轻松完成像流体力学模拟那样的大计算量的物理模拟计算。</p>
<p>目前最火热的两款商业游戏引擎Unreal和Unity都采用PhysX作为它们的物理引擎来模拟物理计算，并且PhysX已经于2014年宣布开源，现在在Github上就能免费下载全部源码。不过需要注册NVIDIA的开发者账号，并注册加入其在Github上的组织才能下载源码。</p>
<p>具体方法请参考<a target="_blank" rel="noopener" href="https://developer.nvidia.com/physx-source-github">这里</a>。</p>
<span id="more"></span>

<h3 id="物理系统"><a href="#物理系统" class="headerlink" title="物理系统"></a>物理系统</h3><p>所谓物理系统，就是针对物理引擎做出的进一步封装，方便开发者添加和使用需要的物理特性。如果你的游戏引擎是基于组件式的架构的话，那么一个简单的物理系统可能需要以下两个基本的物理组件：__Rigidbody__、__Collider__。并且需要一个PhysicsManager来管理物理引擎的初始化、物理模拟和相关资源的释放等。其中每个Collider组件都可以添加物理材质，它仅仅是用来设定物理碰撞时的动静态摩擦力以及反弹系数等数值。</p>
<p>其实物理系统还可以拆分诸多个子系统，比如__布料系统__、__布娃娃系统__、__物理粒子系统__和__Vehicle车辆系统__等。但这里不会做过多的详细介绍，接下来仅会对Rigidbody和Collider的实现原理进行分析说明。</p>
<p>具体的物理系统架构：<br><img src="http://7xlmp2.com1.z0.glb.clouddn.com/2018-08-15%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F.png" alt="01"></p>
<h3 id="Rigidbody组件"><a href="#Rigidbody组件" class="headerlink" title="Rigidbody组件"></a>Rigidbody组件</h3><h4 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h4><p>在游戏场景中，可能会有许许多多的游戏元素，但哪些需要去表现一些物理特性（也就是被物理引擎去模拟计算）呢？这就需要用到Rigidbody组件，例如在Unity中，如果一个GameObject包含Rigidbody组件，那么就可以认为它会受到物理世界的模拟影响，比如自由落体运动。</p>
<p>本质上就是在Rigidbody中维护着一个PxRigidActor类型的指针，它会被添加进PhysX的物理场景中，由物理引擎去模拟计算每一个固定时长帧下的刚体状态变化。在渲染的时候，我们再根据物理引擎计算得出的Rigidbody位置、旋转信息，附加设置到对应GameObject的Transform组件上即可。</p>
<p>下面是PxRigidActor类的继承关系图：<br><img src="http://7xlmp2.com1.z0.glb.clouddn.com/2018-08-15-physx_actor_tree.png" alt="02"></p>
<p>由上图可以发现在PxRigidActor下面，还会继续派生出PxRigidDynamic和PxRigidStatic来。实际上在Rigidbody组件中，会更多地用到PxRigidDynamic的特性，比如质量、阻力、速度等等。而PxRigidStatic更多的是为那些只有Collider组件而没有Rigidbody组件的静态物体所使用，这类静态物体不会受任何力的影响，但会参与到碰撞当中去，并能够给其他有Rigidbody组件的物体以影响。</p>
<h4 id="质量属性"><a href="#质量属性" class="headerlink" title="质量属性"></a>质量属性</h4><p>一个dynamic actor所需的质量属性包括：质量，转动惯量和质心。在PhysX中，计算质量属性的方式是调用__PxRigidBodyExt::updateMassAndInertia()__函数，也可以通过__PxRigidBodyExt::setMassAndUpdateInertia()__来改变刚体的质量分布。</p>
<p>每个PxRigidActor可以动态地维护1到n个__PxShape__，每当shape的增加或减少，我们都应去更新刚体的质量分布以获得更加逼真的物理表现。而每个PxShape的指针，我们会放到Collider组件中去维护，在之后会做详细地介绍。</p>
<h4 id="运动学刚体"><a href="#运动学刚体" class="headerlink" title="运动学刚体"></a>运动学刚体</h4><p>还是拿Unity举例子，当一个Rigidbody组件被设置为IsKinematic时，表示该刚体不再受任何力的作用，但是可以对其他动态刚体施加作用力。刚体实现设置为Kinematic很简单，只需要调用:</p>
<pre><code>PxRigidBody::setRigidBodyFlag(PxRigidBodyFlag::eKINEMATIC, true);
</code></pre>
<p>将刚体设置为Kinematic通常是为了希望可以人为地去改变物体的Transform而不是通过物理引擎的模拟计算结果。但人为修改Transform时，应注意区分__PxRigidDynamic::setKinematicTarget()__和__PxRigidActor::setGlobalPose()__。当使用setGlobalPose()时，仅仅会将actor移动至合适的位置，而不和其他物体发生交互。特别注意的是，Kinematic的刚体使用setGlobalPose()并不会推开经过路径上的其他动态刚体。</p>
<p>如果两个刚体都是Kinematic的，则不会产生碰撞效果，但是可以请求获得企图发生碰撞的两个物体的相关碰撞信息， <strong>PxSceneFlag::eENABLE_KINEMATIC_PAIRS</strong> 或 <strong>PxSceneFlag::eENABLE_KINEMATIC_STATIC_PAIRS</strong> 被设置上即可。</p>
<h3 id="Collider组件"><a href="#Collider组件" class="headerlink" title="Collider组件"></a>Collider组件</h3><h4 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h4><p>Collider组件主要是为了封装PxShape，之前也有说过，每一个物理世界中的物体(PxRigidActor)可能会对应多个PxShape，但是Collider组件只会维护一个PxShape，表示这个碰撞体的指定形状。由于组件化的灵活机制，可能某一个子GameObject只有Collider组件而没有Rigidbody组件，因此要向上查找其Parent GameObject是否持有Rigidbody组件，如果有的话则将该Collider维护着的PxShape指针attach到找到的Rigidbody组件持有的PxRigidActor上（记得需要更新质量分布属性）。</p>
<p>具体架构如下图：<br><img src="http://7xlmp2.com1.z0.glb.clouddn.com/2018-08-15-relation_colliders_pxshape.png" alt="03"></p>
<h4 id="Shapes"><a href="#Shapes" class="headerlink" title="Shapes"></a>Shapes</h4><p>在PhysX中，使用PxShape来描述刚体的空间范围和碰撞属性，当我们创建PxShape的时候，需要先构建PxGeometry和PxMaterial，构建PxGeometry的派生类对象，常见的包括：<strong>Box__、__Sphere__、__Capsule__、__Convex Meshes</strong> 和 <strong>Triangle Meshes</strong> 等。其中TriangleMesh类型的几何体不支持Simulation Shape附加在动态刚体上，除非该刚体被配置为Kinematic。根据不同的Geometry类型，我们可以封装成不同的组件并继承自Collider，一一对应，具体包括：<strong>BoxCollider__、__SphereCollider__、__CapsuleCollider</strong> 和 <strong>MeshCollider</strong> (统一管理Convex和Triangle)。</p>
<p>每个子Collider实现中，要去管理对应Geometry所需的特征数据，如SphereCollider得去维护Sphere Geometry的半径等，剩下的具体计算只需要交给PhysX。无论PxShape对应什么形状，其具体Transform都是位于PxRigidActor坐标系下的，因此我们只能修改PxShape的相对位置。世界坐标系下的Transform信息，应交给PxRigidActor来关心。动态刚体的运动轨迹最好由PhysX计算完成，而静态刚体则可以通过调用 <strong>setGlobalPose()</strong> 函数来进行设置。</p>
<blockquote>
<p><strong>特别注意</strong> :<br><em>1. 在构建或更新Geometry的时候，需要考虑Collider组件对应的GameObject缩放系数</em><br><em>2. 在PhysX中，Capsule是沿X轴方向水平拉长的，如果想做成类似Unity那种沿Y轴方向的效果，需要手动旋转90度</em></p>
</blockquote>
<h4 id="物理材质"><a href="#物理材质" class="headerlink" title="物理材质"></a>物理材质</h4><p>在现实世界中，不同的物体发生碰撞总会产生不同的运动效果。比如汽车在冰面上行驶和在水泥地上行驶的摩擦阻力肯定是不同的。在PhysX中封装了PxMaterial来描述不同物体在物理世界中的个体差异。在构建PxShape时，除了PxGeometry外，PxMaterial也是必须的。</p>
<p>创建一个PxMaterial很简单，只要调用静态函数__PxMaterial::createMaterial()<strong>并传入__静态摩擦力系数__、__动态摩擦力系数</strong> 和 <strong>反弹系数</strong> 就可以了。同时PxMaterial还支持设置摩擦力结合模式和反弹结合模式，可根据发生碰撞的两个物体的物理材质系数，取平均值、最大值和最小值等。</p>
<h3 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h3><p>一般的碰撞检测算法，都要分2个阶段：<strong>Broad Phase</strong> 和 <strong>Narrow Phase</strong> 。其中Broad Phase主要用于构建场景中碰撞盒的BVH(Bounding Volume Hirerarchy)。通过构建BVH，来配对(潜在)碰撞盒。而在Narrow Phase中，会对Broad Phase已确定的碰撞盒进行二次检测，确定最终的碰撞结果。在PhysX中，Broad Phase主要的算法包括 <strong>SAP(Sweep And Prune)</strong> 和 __MBP(Multi Box Pruning)__。具体关于SAP的介绍，可以参考<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Sweep_and_prune">这里</a>。</p>
<p>使用MBP算法，同时会引入Regions的概念。Regions就是世界坐标系下的AABB包围盒体积空间，该空间外的所有物体不会进行碰撞检测，理想情况下应该覆盖到整个游戏空间，并且最大数量不要超过256。出于对性能的考虑，尽量不要让不同的Regions相互重叠，两个Regions的AABB仅仅触碰并不算重叠。</p>
<p>创建物理场景时，可以指定一个 <strong>PxSimulationFilterCallback</strong> 的回调函数指针。该回调将会在场景中所有的shape pair的包围盒第一次相交时执行，并根据回调的返回值来确定接下来的行为。每一个PxShape对象中都持有一个 <strong>PxFilterData</strong> 类型的成员变量，用128bit的数据来指定跟Collision Filter有关的信息，这些信息都会在PxSimulationFilterCallback回调中以PxFilterData类型的参数传递进来，同时回调参数还包括一块指定大小的内存，可以用来传递更多的数据信息，需要在构建PxSceneDesc时指定 <strong>filterShaderData</strong> 和 <strong>filterShaderDataSize</strong> 。</p>
<p>利用这一灵活的特性，我们可以方便地实现__动态__设置刚体是否支持 <strong>CCD(Continuous Collision Detection)</strong> 和__按层过滤碰撞机制__。这两个功能可以有效地提高物理模拟的性能，减少一些不必要的计算消耗。每一个PxFilterData只包含4个int类型的成员(word0~word3)，我们可以先用word3来表示发生碰撞的对应shape是否支持CCD，具体的设置需要放到Collider组件中，查找其对应依附的Rigidbody组件并获取其CCD支持状态。具体代码如下:</p>
<pre><code>PxU32 filterFlags0 = (filterData0.word3 &amp; 0xFFFFFF);
PxU32 filterFlags1 = (filterData1.word3 &amp; 0xFFFFFF);
bool ccdCondition0 = (filterFlags0 &amp; CCD_MODE::DYNAMIC) &amp;&amp; !(filterFlags1 &amp; CCD_MODE::OFF);
bool ccdCondition1 = (filterFlags0 &amp; CCD_MODE::NORMAL) &amp;&amp; (attributes1 &amp; PxFilterObjectType::eRIGID_STATIC);
if (!(k0 &amp;&amp; k1) &amp;&amp; (ccdCondition0 || ccdCondition1))
&#123;
    pairFlags |= PxPairFlag::eSOLVE_CONTACT;
    pairFlags |= PxPairFlag::eDETECT_CCD_CONTACT;
&#125;
pairFlags |= PxPairFlag::eDETECT_DISCRETE_CONTACT;
</code></pre>
<p>其中pairFlags是回调的引用参数，用于输出碰撞对的状态。</p>
<p>至于按层过滤碰撞机制，实现方式类似，不过要用到filterShaderData。在filterShaderData中存储着一个长度为32的uint32_t数组，里面每一个int的每一个bit用来表示不同层之间的碰撞关系(0表示不支持碰撞，1表示支持碰撞)。因此这就限制了层的最大上限只能是32，实际上Unity的实现也是如此。与此同时，我们可以使用PxFilterData.word0来标识对应Collider的隶属层的索引，通过位运算来计算出是否支持产生碰撞，不支持则直接函数返回 <em>PxFilterFlag::eSUPPERESS</em> 。代码片段如下：</p>
<pre><code>PxU32 shapeGroup0 = (filterData0.word0 &amp; 0xFFFFFFFF);
PxU32 shapeGroup1 = (filterData1.word0 &amp; 0xFFFFFFFF);
uint32_t* groupCollisionFlags = (uint32_t*)constantBlock;
if ((groupCollisionFlags[shapeGroup0] &amp; (1 &lt;&lt; shapeGroup1)) == 0)
&#123;
    return PxFilterFlag::eSUPPRESS;
&#125;
</code></pre>
<p>其中constantBlock就是指在构建物理场景时传入的层碰撞状态数组。</p>
<h3 id="固定步长刷新"><a href="#固定步长刷新" class="headerlink" title="固定步长刷新"></a>固定步长刷新</h3><p>渲染，表现的只是游戏时间中的一瞬间，通常不需要关心距离上次渲染过去了多少时间，因此会放到变时步长刷新中。但是物理模拟运算不同，它需要一个合理的固定步长刷新机制，来使得物理表现更加逼真、稳定。也就是说，我们以固定时间步长来更新模拟物理计算，但渲染的时间点却是随机的，让我们看看时间线：</p>
<p><img src="http://7xlmp2.com1.z0.glb.clouddn.com/2018-08-15-timeline-with-update.png" alt="04"></p>
<p>如上图所见，时间线上端的“更新”表示一次物理模拟运算，它们之间的间隔是相同而紧凑的，但是渲染发生的位置是不固定的并且通常频率会低于更新。因此，我们并不能保证总在更新的时间点进行渲染，观察下第三次和第四次渲染，它们就是发生在两次更新之间。试想一颗子弹横穿屏幕，首次更新它在屏幕的左侧，而第二次更新它将移动到屏幕的右侧，如果渲染在两次更新之间进行，并且只根据前一次更新结果的话，子弹会被渲染到屏幕的左侧，而我们更希望子弹出现在屏幕的中间某一位置。</p>
<p>为了更逼真的物理运动表现，或减少一些不必要的抖动问题，就要求我们去做一些额外的差值运算。在Unity的刚体组件中，提供了设置Interpolate来选择差值方式，其中Interpolate表示根据前一固定帧来进行差值计算，Extrapolate则表示预测下一固定帧的位置来进行差值计算。</p>
<p>所需的差值计算方式可以交给Rigidbody组件来记录，除了Interpolate和Extrapolate之外，当然也可以什么都不做，即None。假设用于渲染的变时步长回调为update()，用于物理模拟运算的定时步长回调为fixedUpdate()。在每次fixedUpdate回调中执行物理场景的simulate()函数之前，遍历物理场景下的所有动态刚体，如果刚体为Interpolate模式，要把对应刚体的位置和旋转记录下来。等执行update()回调的时候，Interpolate模式下，会根据之前记录的位置、旋转信息与当前刚体的信息进行差值计算。而Extrapolate模式下，在update()回调中会根据动态刚体的velocity和angularVelocity来预测计算出当前渲染时间点的刚体位置和旋转数据来。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/guide/Manual/Index.html">PhysX SDK</a><br><a target="_blank" rel="noopener" href="https://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/apireference/files/index.html">PhysX API</a><br><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/Physics3DReference.html">Unity Manual 3D Physics Reference</a></p>

    </div>

    
    
    
        <div class="reward-container">
  <div>您的赞赏是我前进的动力</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="xujh 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>xujh
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://aiplay.studio/2018/08/15/2018-08-15-build-physics-system/" title="使用PhysX构建简单的物理系统">http://aiplay.studio/2018/08/15/2018-08-15-build-physics-system/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/images/wechat_channel.jpg">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/physics/" rel="tag"> <i class="fa fa-tag"></i> physics</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/03/29/2018-03-29-vps-build-ss/" rel="prev" title="购买vps搭建ss服务教程">
      <i class="fa fa-chevron-left"></i> 购买vps搭建ss服务教程
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/30/2020-04-30-talk-about-ecs/" rel="next" title="聊聊ECS架构与实际应用">
      聊聊ECS架构与实际应用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#PhysX%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E"><span class="nav-number">1.</span> <span class="nav-text">PhysX物理引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.</span> <span class="nav-text">物理系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rigidbody%E7%BB%84%E4%BB%B6"><span class="nav-number">3.</span> <span class="nav-text">Rigidbody组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%A6%81"><span class="nav-number">3.1.</span> <span class="nav-text">概要</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="nav-number">3.2.</span> <span class="nav-text">质量属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E5%8A%A8%E5%AD%A6%E5%88%9A%E4%BD%93"><span class="nav-number">3.3.</span> <span class="nav-text">运动学刚体</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collider%E7%BB%84%E4%BB%B6"><span class="nav-number">4.</span> <span class="nav-text">Collider组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%A6%81-1"><span class="nav-number">4.1.</span> <span class="nav-text">概要</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Shapes"><span class="nav-number">4.2.</span> <span class="nav-text">Shapes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E6%9D%90%E8%B4%A8"><span class="nav-number">4.3.</span> <span class="nav-text">物理材质</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B"><span class="nav-number">5.</span> <span class="nav-text">碰撞检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E6%AD%A5%E9%95%BF%E5%88%B7%E6%96%B0"><span class="nav-number">6.</span> <span class="nav-text">固定步长刷新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="xujh"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">xujh</p>
  <div class="site-description" itemprop="description">爱生活 | 爱丸子</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AIplay Studio</span>
</div>
  <div id="site-runtime">
  <span class="post-meta-item-icon">
    <i class="fa fa-clock-o"></i>
  </span>
  <span id="runtime"></span>
</div>

<script language="javascript">
  function isPC() {
    var userAgentInfo = navigator.userAgent;
    var agents = ["Android", "iPhone", "SymbianOS", "Windows Phone", "iPad", "iPod"];
    for (var i = 0; i < agents.length; i++) {
      if (userAgentInfo.indexOf(agents[i]) > 0) {
        return false;
      }
    }
    return true;
  }

  function siteTime(openOnPC, start) {
    window.setTimeout("siteTime(openOnPC, start)", 1000);
    var seconds = 1000;
    var minutes = seconds * 60;
    var hours = minutes * 60;
    var days = hours * 24;
    var years = days * 365;
      start = new Date("2014-11-23 09:00:00 +0800");
    var now = new Date();
    var year = now.getFullYear();
    var month = now.getMonth() + 1;
    var date = now.getDate();
    var hour = now.getHours();
    var minute = now.getMinutes();
    var second = now.getSeconds();
    var diff = now - start;

    var diffYears = Math.floor(diff / years);
    var diffDays = Math.floor((diff / days) - diffYears * 365);
    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);

    if (openOnPC) {
      document.getElementById("runtime").innerHTML = "Running: " + diffYears + " years " + diffDays + " days " + diffHours + " hours " + diffMinutes + " mins " + diffSeconds + " secs";
    } else {
      document.getElementById("runtime").innerHTML = "Running: " + diffYears + "y " + diffDays + "d " + diffHours + "h " + diffMinutes + "m " + diffSeconds + "s";
    }
  }

  var showOnMobile = false;
  var openOnPC = isPC();
  var start = new Date();
  siteTime(openOnPC, start);

  if (!openOnPC && !showOnMobile) {
    document.getElementById('site-runtime').style.display = 'none';
  }
</script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
